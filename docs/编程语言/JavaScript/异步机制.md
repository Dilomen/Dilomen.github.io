## 概述

什么是异步？由于 JavaScript 是一门单线程语言，所以在执行的时候会出现堵塞的情况,为了避免长时间的等待,JS 引入了异步的概念,将等待的任务先放到异步队列，这样就不会堵塞后面的代码执行。

## 历史

### 回调函数 callback

将代码嵌套执行

- 函数作为实参执行

```js
function Test(callback) {
  callback();
}
function sayHello() {}
Test(sayHello);
```

- jquery 中的 ajax 请求

```js
$.ajax({
  url: '/',
  success: function() {},
  fail: function() {},
});
```

::: tip jQuery-deferred
jQuery-deferred 是为了改变 callback 书写的回调地狱（代码格式很混乱）而生的，其使用了链式调用的方式，Promise 就是借鉴该方式的
:::

```js
var ajax = $.ajax('./data.json');
ajax
  .done(function() {
    console.log('success 1');
  })
  .fail(function() {
    console.log('fail 1');
  })
  .done(function() {
    console.log('success 2');
  })
  .fail(function() {
    console.log('fail 2');
  });

var ajax = $.ajax('./data.json');
ajax
  .then(
    function() {
      console.log('success 1');
    },
    function() {
      console.log('fail 1');
    }
  )
  .then(
    function() {
      console.log('success 2');
    },
    function() {
      console.log('fail 2');
    }
  );
```

### Promise

Promise 是 ES6 提出一种异步解决方案，可以链式调用执行，解决回调地狱的问题。

#### Promise 有三种状态:

- 进行中（pending）：操作还未开始
- 处理成功（Fulfilled）：操作成功
- 处理失败（Rejected）：由于程序出错或别的原因，未能成功

#### API

可以通过 then,catch 分别获取到成功和失败返回的内容

```js
new Promise((resolve, reject) => {
  if (success) {
    resolve("success");
  } else {
    reject("fail");
  }
}).then(res => {...}).catch(err => {...});
```

### Generater

同样是 ES6 提出的另一种解决方案。可以不用使用太长的链式调用，书写更加清晰。

```js
function *generater() {
    yield 1
    yield 2
    yield 3
}
let a = generater()
a.next(); { value: 1, done: false }
a.next(); { value: 2, done: false }
a.next(); { value: 3, done: true }
```

### Async/Await

ES7 提出的异步解决方案，本质是由 Generater 和 Promise 实现的语法糖，可以让我们以同步的方式书写异步代码。

```js
async function test() {
    let a = await (...)
    ...
}
```

## 宏任务和微任务

#### js 的异步代码分为宏任务和微任务

- 宏任务：同步代码，setTimeout，setInterval 等。
- 微任务：Promise.then、catch finally，process.nextTick 等

**执行机制**：js 执行栈先执行宏任务队列，然后遇到微任务，就将微任务加入微任务队列，等待宏任务栈中的所有任务结束，再执行所有微任务，微任务结束再执行宏任务...
:::tip 补充
一个 setTimeout 中的任务会在下一个 setTimeout 任务前执行

```js
setTimeout(() => {
  new Promise((resolve) => {
    resolve(1);
  }).then((data) => {
    console.log(data);
  });
});

setTimeout(() => {
  console.log(2);
});

// 结果1 2
```

:::

## 异步经典问题

`async` ，`await`，`setTimeout`，`Promise`函数的执行顺序

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}
async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

async1();

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
});
console.log('script end');
```

**答案：**

- 先执行宏任务 console.log(script start)，然后遇到 setTimeout，加入宏任务列，然后 async1()，执行 await 前和后面 async2()，将 console.log('async1 end');加入微任务，然后 new Promise，执行 console.log('promise1');将.then 后的代码加入到微任务，接着执行 console.log('script end');，此时宏任务都结束，执行微任务，按顺序 console.log('async1 end');， console.log('promise2');，刚微任务都执行完成，再执行宏任务 setTimeout
- 首先可以将 async 下的代码在 await 之前和后面的语句当做立即执行函数，而再后面的可以当做回调后的,且后面的必须是 await 紧跟语句全部执行完才能执行，包括 await 紧跟后面的是 new promise，也要执行完.then 之后的才能执行下面的，因为 async/await 是 promise 的语法糖，所以可以转化为 new Promise((async2()) => {console.log(“async end1”)})，然后 promise 可以将.then 和.catch 作为回调，而之前的也是作为直接执行 promise 和 anysc 都会在 setTimeout 前执行，所以程序下来我们会先遇到 script start 同步代码的输出，然后 anysc1()，直接执行 await 前面的和紧跟的代码，接着遇到了 promise，也是执行.then 前面的，再者，遇到了 script end 的同步代码，然后执行 anysc 下 await 后面的代码，接着是 promise 后面.then 的代码，最后是 setTimeout 的代码

```md
script start  
async1 start  
async2  
promise1  
script end  
async1 end  
promise2  
setTimeout
```
