### 柯里化函数

柯里化函数就是将原本接受多个参数的函数变成可执行为接受部分参数，并返回接受剩下参数的新函数

### 例子 1

```js
function add(a, b, c, d) {
  return a + b + c + d;
}
function curry(fn) {
  let argLen = fn.length,
    args = [];
  return function core() {
    let arg = [].slice.call(arguments);
    args = args.concat(arg);
    argLen -= arg.length;
    return argLen === 0 ? fn.apply(null, args) : core;
  };
}

var func = curry(add);
console.log(func(1, 2)(3));
```

```js
const curry = (fn, n = fn.length, args = []) =>
  n === 0
    ? fn(...args)
    : (...args1) => curry(fn, n - args1.length, [...args, ...args1]);
```

### 复合函数

复合函数就是将多个函数作为参数传入，然后通过每一个函数的调用，返回结果。一个函数的返回值将作为另一个函数的参数

```js
function compose() {
  const args = [...arguments];
  const len = args.length - 1;
  return function(data) {
    return args.reduceRight(function(res, cb) {
      return cb(res);
    }, data);
  };
}
```

### 例子 2

```js
function fn1(value) => value + 1
function fn2(value) => value + 2
const composeFn = compose(fn1, fn2)
composeFn(1) // 4
```

## 异步处理

```js
function compose() {
  const args = [...arguments];
  const len = args.length - 1;
  return async function(data) {
    let result;
    let promiseFn = tryPromiseFunc(args[len], data);
    for (let i = len; i > 0; i--) {
      promiseFn = promiseFn.then((res) => {
        console.log(res);
        return tryPromiseFunc(args[i - 1], res);
      });
    }
    return promiseFn;
  };
}

function tryPromiseFunc(func, ...params) {
  return new Promise((resolve, reject) => {
    try {
      const res = func(...params);
      if (res instanceof Promise) {
        res.then((data) => resolve(data)).catch((err) => reject(err));
      } else {
        resolve(res);
      }
    } catch (err) {
      reject(err);
    }
  });
}
```
