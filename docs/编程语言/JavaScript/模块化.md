## 概述

模块化就是将复杂的系统分解成高内聚，低耦合的模块，让系统开发变的更加易于管理、可测试和可维护，以及解决了出现全局污染的问题。

```html
<!-- 全局污染 -->
<script type="text/javascript">
  let a = 1;
</script>
<script type="text/javascript">
  a = 2;
</script>
```

## 初代模块化

为了解决全局的问题，借助了函数作用域的语言特性，和立即执行函数 IIFE 进行封装，通过“私有变量”的特性构建局部变量，由返回函数将其形成闭包保留，这种创建模块的方式成为**模块模式**。代表有 YUI，jQuery 等。

```js
var Foo = (function() {
  var count = 1;
  return {
    addCount: () => {
      count += 1;
    },
    getCount: () => {
      return count;
    },
  };
})();
Foo.addCount();
console.log(Foo.getCount());
```

也可以通过立即执行函数的参数作为不同“模块”之间的交互

```js
var Foo = (function(Fn) {
  var count = 1;
  var result = Fn(count);
  return {
    getResult: () => {
      return count;
    },
  };
})(handle); // 传入参数
```

可以从上述看出，模块模式并**没有解决依赖关系，需要开发者自己关注依赖顺序和依赖管理**，这对于大型应用是非常不友好的，还有个问题就是，不能很方便的访问内部属性（只能通过闭包读取）

为了解决这两个问题，于是 JS 出现了两个标准

- AMD：主要是服务于浏览器，实现有 RequireJS
- CommonJS：面向通用 JAvaScript 环境（如 Node 服务端）

## AMD

AMD（Asynchronous Module Definition，异步模块定义）采用了异步加载模块的方式，当其加载完毕后，通过回调的形式，执行依赖该模块的语句。

[AMD 规范](https://github.com/amdjs/amdjs-api/wiki/AMD)

- 自动处理依赖，无需关系依赖顺序
- 异步加载，没有阻塞
- 在一个文件内可以定义多个模块

```js
/**
* define(id?, dependencies?, factory);
* - id: 新创建模块的ID
* - dependencies: 当前模块依赖的模块ID列表
* - factory: 依赖模块列表工厂初始化的结果作为参
*/
define('Module1', ['jQuery'], $ => {
  const fn = () => {
    // do something
  }
  return {
    onClick: () => {
      $(document).on('click', fn);
    }
  }
}
```

## CommonJS

CommonJS 主要是服务于服务端的，所以不需要考虑浏览器网络加载的问题（该模块语法也不能在浏览器直接运行），其实现是同步声明依赖的模块定义。

:::tip
Node 模块系统借鉴了 CommonJS，但是还是有一些自己的改动
:::

- 语法简单
- 同步执行
- 以文件为单位作为模块，不能在一个文件内声明多个模块

```js
const path = require('path');
module.exports = {
  getResolvePath: (path) => path.resolve(__dirname, path);
};
```

为了解决 AMD 和 CommonJS 环境不同的兼容性问题，又衍生出了一个通用方案 ———— UMD（Universal Module Definition，通用模块定义）。
[UMD](https://github.com/umdjs/umd/blob/master/README.md)

## ES Modules

鉴于迫切的的需求，ECMAScript 标准终于提出了一个新的模块标准————ESM。其结合了 CommonJS 和 AMD 的优点，简易的模块语法，基于文件（一个文件就是一个模块）以及支持异步加载，当然它支持两个环境的执行。

**语法**

| 含义         | 写法                                                          |
| ------------ | ------------------------------------------------------------- |
| 导出变量     | `export const STATE = true;`                                  |
| 导出函数     | `export const Foo = () => {};` OR `export function Foo() {};` |
| 导出默认     | `export default Foo;`                                         |
| 导出多个变量 | `export { Foo, STATE };`                                      |
| 使用别名导出 | `export { Foo as MyFoo };`                                    |
| 导入多个变量 | `import { Foo, STATE } from './xxx.js';`                      |
| 导入全部内容 | `import * as xxx from './xxx.js';`                            |
| 别名导入变量 | `import { MyFoo as Foo } from './xxx.js';`                    |

## ESM 和 CommonJS 的区别

### 导出值处理

CommonJS 是值拷贝(类似函数传参)，而 ESM 是值引用，即导出的内容会根据模块内的变化而变化

这是因为 CommonJS 导出时的值和后面改变的值的内存地址不是同一个，如果导出的是对象，那么地址存储不是同一个，但是指向的内存数据是同一个，所以对象属性改变，也会改变，等同于浅拷贝。

而 ESM 使用的是实时绑定（Live Binding），当模块内值发生改变时，直接修改的是其地址的内容，而不是新的内存地址

```js
// b.js
let state = true;
module.exports = {
  state,
};
state = false;

// a.js
const b = require('./b');
console.log(b.state); // true
```

```js
// b.js
export let state = true;
state = false;

// a.js
import * as b from './b';
console.log(b.state); // false
```

### 循环依赖

CommonJS 存在循环依赖的问题，主要是因为其是对值拷贝的原因，导致了其引入的模块内容不会因为模块的变更而改变。
而 ESM 不存在循环依赖的问题是因为它实时读取，不关心读的数据不对

```js
// a.js
const b = require('./b');
console.log(b.state);

module.exports = {
  state: 1,
};
```

```js
// b.js
const a = require('./a');
console.log(a.state);

module.exports = {
  state: 3,
};
```

```js
node a.js
```

首先遇到 b 模块，那么就执行，遇到了 a 模块，那么就认定为是循环加载了，所以不会执行 a 模块的后续内容，这时 a 就没有拿到，所以先输出 undefind，然后执行完 b 模块后，a 模块已经拿到执行结果，所以输出 3

### 加载方式

CommonJS 是动态加载，而 ESM 是静态加载

动态加载就是当运行时才能知道引用的模块，输出的是对象，值会被缓存

```js
require(`${module}`);
```

静态加载是在编译时处理，ESM 有一个模块依赖的解析阶段（静态分析），模块输出的是引用，因此可以去掉一些没有使用到的代码，这也是能够实现 Tree Shaking 的主要原因

:::tip
ES2020 支持 import 动态加载，返回一个 Promise

```js
if (flags) {
  import(`${module}`).then();
}
```

:::

### 只读

ESM 的 import read-only 特性

```js
import * as b from './b';

b = 1; // Error: "b" is read-only.
```

### 提升

ESM 存在 export/import 提升

```js
console.log(b.state); // false
import * as b from './b';
```

## 浏览器支持

多数浏览器已经[支持](https://caniuse.com/?search=ES6%20modules)了引入模块脚本  
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81)

```html
<script type="module" src="./a.mjs"></script>
<script type="module" src="./b.mjs"></script>
```

```js
// a.mjs
import * as b from './b.mjs';
console.log(b.state);
```

```js
// a.mjs
export let state = true;
state = false;
```

.mjs拓展名是为了更清晰的分辨是模块，也可以使用.js后缀

## 参考

- [《模块化系列》彻底理清 AMD,CommonJS,CMD,UMD,ES6](https://juejin.cn/post/6844904066233925639)
- [Nodejs 模块加载与 ES6 模块加载实现](https://segmentfault.com/a/1190000020007221)
- [JavaScript 模块的循环加载](http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html)
- 《JavaScript 高级程序设计》（第 4 版）
- 《JavaScript 忍者秘籍》（第 2 版）
- 《深入理解 ES6》
