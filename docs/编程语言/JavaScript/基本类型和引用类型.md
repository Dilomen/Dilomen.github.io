## 基本类型和引用类型

:::tip
JS 基本类型 ———— **Number,String,Boolean,null,undefined,Symbol**,以及下个版本的 **BigInt**  
JS 引用类型 ———— **Object,Array,Function**
:::

> JavaScript 作为一个弱类型语言，但也有自己的基本类型，所谓的弱类型，是指程序动态转化变量类型，如 1 和“1”进行==比对时，程序会将 1 由 Number 通过 toString()的方式转化 String，然后和“1”进行对比

## 存储

- 基本类型：保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问

- 引用类型：保存在堆内存中，因为这些值的大小是不固定的，但是内存地址值的大小是固定的，所以在栈保存内存地址，所以通过先访问栈中的内存地址，再通过地址找到堆中的值

## 判断类型

### typeof

- 基本类型
  | typeof 变量 | 类型 | | typeof 变量 | 类型 |
  | ---------| ---------- | --- | ----------- | ----------- |
  | typeof '' | "string" | | typeof null | "object" |
  | typeof 1 | "number" | | typeof undefined | "undefined" |
  | typeof true | "boolean" | | typeof Symbol() | "symbol" |
  | typeof BigInt(1) | "bigint" |

- 引用类型
  | typeof 变量 | 类型 | | typeof 变量 | 类型 |
  | ----------- | ---------- | --- | -------- | ----------- |
  | typeof {} | "object" || typeof [] | "object" |
  | typeof function() {} | "function" || typeof new String('a') | "object" |

:::warning 特别注意：

- typeof 变量出的结果都是**String 类型**
- null 的 typeof 结果是"object",undefined 的结果是"undefined"， 引用类型的 typeof 结果除了 function 别的都是"object"
  :::

### instanceof

> instanceof 运算符用于**检测构造函数的 prototype 属性**是否出现在某个实例对象的原型链上 —— MDN

> 就是判断一个实例对象的原型链上是否有 instanceof 右边指定的类

> 首先在 JavaScript 中，一切皆对象，所有的变量都是继承 Object 的，而这个继承即使通过原型链实现的，所以我们可以通过查看变量的继承来判断类型

| 变量                                         | 类型 |
| -------------------------------------------- | ---- |
| ({}) instanceof Object                       | true |
| [] instanceof Array                          | true |
| var a = new String('a'); a instanceof String | true |
| var a = new Date(); a instanceof Date        | true |

### Object.prototype.toString.call()

> Object.prototype.toString 可以检测对象类型

:::tip 注意
为什么要用 Object.prototype.toString.call 而不是直接使用 toString()？  
因为不同的对象下的 toString 会被重写，只有他们的祖先类 Object 下原型的 toString 才能够正确的执行我们想要的结果
:::

| 变量                                          | 类型                 |
| --------------------------------------------- | -------------------- |
| Object.prototype.toString.call(1)             | "[object Number]"    |
| Object.prototype.toString.call("a")           | "[object String]"    |
| Object.prototype.toString.call([])            | "[object Array]"     |
| Object.prototype.toString.call({})            | "[object Object]"    |
| Object.prototype.toString.call(function() {}) | "[object Function]"  |
| Object.prototype.toString.call(undefined)     | "[object Undefined]" |
| Object.prototype.toString.call(null)          | "[object Null]"      |

## undefined 和 null 的区别

undefined 是指一个变量被声明了，但是未被初始化， 如： var a  
null 是指空对象指针

## 显式和隐式转换

> 在 JavaScript 中，声明的**变量是没有类型的，只有值才有类型**，也就是其作为动态语言，到执行时才知道类型

#### 显示转换

显示转化就是我们通过方法强行转换，如果高精度转成低精度的，会有损失精度,强制类型转换主要有：Boolean、Number、String、parseInt、parseFloat
例如： Number("1") 就是显式的将 String 转化为 Number 类型

#### 隐式转换

隐式转换，就是 JS 作为一门动态语言，自动处理的转换(有时候会造成 BUG，这也是 JS 比较坑的地方)  
如==进行比较的时候，如果两者类型不同，JS 就会进行隐式转换，又或是"1" \* 2 这些运算时，都是隐式转换

#### 隐式转换过程

- **关系运算符会把类型转化为 Number 进行比较**
  当一边有数字时，会把另一边的类型通过 Number()的方式转化为数字后进行比较
- **字符串和字符串的比较,根据编码进行比较（同样符合上一条）**
  - 如果两边都是字符，"a" > "b"，那么两者会调用 charCodeAt 的方法查看字符的 unicode 编码，根据编码比较大小  
     如"a"的编码是 97，"b"的编码是 98，所以返回的是 false，
  - 如果是字符串，就会按顺序比对每一个字符的编码，一旦比出大小就返回结果  
     如："2" > "10"，"2"的编码大于"1"，所以成立
- **运算符**
  - x+"" ——> String(x)
  - +x ——> Number(x)
  - !!x ——> Boolean(x)
- **复杂类型会先转成 String，然后转成 Number 进行运算**

  - 首先会调用 valueOf 将变量转化原始值(基本类型的值)进行判断，如果没法得到简单的基本类型的值，那么它会使用 toString 的方法，转化成字符串后，再通过上面的条例 1 或者条例 2 进行判断

:::tip 提问：那为什么"1" + 1 = 11,不是应该通过 valueof 将"1"转化为 1 吗
当进行 + 操作时，如果一个操作数是字符串，那么当前运算就会是**字符串拼接操作**
:::
:::tip 提问：[] ? true : false , [] == false, [] == ![], ({}) == false

- 第一个[]会被隐式转换 Boolean([])，变成 true，所以返回是 true
- 第二个是[]会先通过 valueOf 方法，发现取不到基本类型的值，就使用 toString 方法，变成""，所以""==false 成立
- 第三个![]会被转化为 false，由第二个可知，所以也成立
- 第四个{}也会先通过 valueOf 方法，发现取不到，使用 toString()，变成"[object Object]"，所以({})==false 返回的是 false
  :::

## 包装类

> 首先创建基本类型的变量，可以通过字面量的方式，也可以通过构造函数生成对象的方式
> 后者就是所谓的包装类，将原先的变量从基本类型转变成了引用类型，它将会继承 Object 的方法

#### 但是为什么我字面量创建的变量，也可以使用 Object 的方法，根本没必要使用包装类啊？？？

这就要怪 js 是一门动态语言，当我们为字面量创建的变量添加方法时，js 会自动为基本类型进行**包装**，会做如下处理：

```js
var str = "hello";
var str1 = str.substring(2);
// ---------js处理--------
// 创建String类型的一个实例;
var _str = new String("hello");
在实例上调用指定的方法;
var str1 = _str.substring(2);
销毁这个实例;
_str = null;
// ---------js处理--------
```

## 关于 Number 有话说

Number 有两个特殊值，一个是 NaN，一个是 Infinity

- NaN

  - 指变量不是一个数字
  - typeof NaN 还是"number"
  - NaN==NaN --> false, NaN 不等于任何变量
  - NaN + 1 --> NaN, NaN 和任何变量的运算都是 NaN
  - 可以使用 isNaN 来判断变量不是数字

- Infinity

  - 是指无穷，即变量的大小已经超过了所能展示的数值大小

- `0.1 + 0.2 === 0.3 // false`
  - 这是二进制浮点数精度不够导致的问题，所有遵循 IEEE 754 规范的语言都是这样，0.1 + 0.2 的结果是 0.30000000000000004

## 函数 —— 特殊的对象

- 函数作为 JS 的第一公民，可以作为参数，可以被调用，可以被赋值等等操作
- 函数不仅是对象，还可以拥有属性
- 函数的 length 是其声明的参数个数

## BigInt

由于 JS 中的 Number 类型只能表示-9007199254740991 (<em>-(2^53-1)</em>) 和 9007199254740991(<em>2^53-1</em>)之间的整数，如果超出这个范围，那么就会失去精度(主要表现为用科学记数法)。

```js
console.log(999999999999999999999); // 1e+21
9007199254740992 === 9007199254740993; // true
```

BigInt 就是利用了字符串来表示大整数，就不会在使用超出安全范围的整数出现精度的问题
用法：只需要在大整数后面加个 n 或者使用 BigInt 构造函数包裹 BigInt()，内容可以用不同的进制表示

```js
console.log(999999999999999999999); // 1e+21
console.log(999999999999999999999n); // 999999999999999999999n
console.log(BigInt(999999999999999999999)); // 999999999999999999999n
console.log(typeof 999999999999999999999n); // "bigint"
```

由于类型的不同，所以和 Number 的数字在===的情况下不等于，但是在==的情况下可以进行隐式转换。

```js
console.log(10n === 10); // false
console.log(10n == 10); // true
```

:::tip 隐式类型转换
不支持 BigInt 和 Number 混合操作，即不会进行隐式类型转换，报 TypeError 错误
一些 JS 函数，如 Math 类下的方法也是不支持对 BigInt 进行隐式转换，即参数不能传 BigInt 类型，报 TypeError 错误

如必须要进行以上的操作，可以使用强制转换类型，需要注意的是 BigInt()只能强制转换那些可以被转换为整数的类型
:::
