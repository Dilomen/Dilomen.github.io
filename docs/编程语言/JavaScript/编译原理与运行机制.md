## 前言

高级编程语言根据执行状态可分为<em>编译型语言</em>和<em>解释型语言</em>

- 编译型语言  
  源程序 -> 中间代码 -> 目标代码 -> 执行

- 解释型语言  
  源程序 -> 边解释边执行

:::tip
javaScript 被指明为解释型语言，是因为其直接解释执行，而不需要编译为中间代码。
但是也可以看到 js 在执行前还是会做优化的，比如变量提升等操作，这是由于浏览器厂商为了提升 JS 的性能所做的 <em>JIT（即时编译）</em>，它会将一些循环等重复工作先编译成一个版本，当再次遇到就不需要在编译，而是直接用编译好的。
:::

## 编译过程

解释型语言也是需要编译的，编译过程由宿主环境（浏览器或 Node）来执行完成

- 词法分析：

  - 词法规则：符号书写规则，如非法字符，关键字或标识符拼写错误
  - 处理：把语句分解成词法单元，即 Token

    ```js
    var a = 1
    会被词法分析器识别为：var, a, =, 1  并且加上识别标识
    ```

- 语法分析
  - 语法规则：符号构成语法成分的规则，如语法结构出错，if endif 不匹配
  - 处理：将 Token 转化为<em>抽象语法树（AST）</em>
- 语义分析
  - 语义规则：语义检查，如死循环，零除数，其它逻辑错误

## 预解析

该操作会将变量声明 var 和函数声明 function 做提升操作，<em>函数声明要比变量声明优先级更高</em>。

变量声明时只是<em>声明</em>，而函数声明时是<em>声明+定义（赋值）</em>

1、函数先声明并赋值了，所以输出的就是 function

```js
function a() {}
var a;
console.log(a); // function a() {}
```

2、函数先声明并赋值了，但是 a 又被赋值成 1 了，所以输出的就是 1

```js
function a() {}
var a = 1;
console.log(a); // 1
```

## 执行机制

JavaScript 是一门单线程语言（因为要保证不能冲突操作 DOM），所以在执行的时候会出现堵塞的情况，为了避免长时间的等待，JS 引入了异步的概念，将等待的任务先放到异步队列，然后当同步代码执行完毕，再 Event Loop 来调取异步队列的任务

对于一些事件的处理和处理函数的调用是异步

- 浏览器事件，如页面加载完成
- ajax 网络请求事件
- 用户操作事件，如点击，键盘
- 计时器事件，setTimeout

#### 调用栈

由于 JavaScript 是单线程的，所以只能在某一刻执行某个代码，而不能同时执行。
一旦函数发生调用当前的执行上下文就必须停止，并创建新的函数执行上下文，直到函数执行完成，将函数执行上下文销毁，返回到调用的执行上下文。所以被称为调用栈，是一种先进后出的数据结构。

```js
function outer() {
  console.log('outer');
  inner();
}
function inner() {
  console.log('inner');
}
outer();
```

1. 程序开始，就会创建一个全局执行上下文
2. 首先全局调用了 outer 函数，所以创建了 outer 函数执行上下文
3. 在 outer 里又调用了 inner 函数，所以有创建了 inner 函数上下文
4. inner 函数执行完成，回到 outer 函数执行上下文
5. outer 函数执行完成，回到全局执行上下文
   <a data-fancybox title="js调用栈" href="/JavaScript/js调用栈.png">![js调用栈](/JavaScript/js调用栈.png)</a>

同样也可以在 chrome 浏览器的调试中观察到

<a data-fancybox title="js调用栈_chrome" href="/JavaScript/js调用栈_chrome.png">![js调用栈_chrome](/JavaScript/js调用栈_chrome.png)</a>

#### 事件循环(Event Loop)

JavaScript 是只有一个主线程和一个调用栈，调用栈会将要执行的任务通知主线程，让主线程来执行。

- 1:调用栈顺序调用任务队列中任务
- 2:当调用栈发现异步任务时，会将异步代码放到异步队列，接着执行下面的代码
- 3:同步代码执行完毕，当主线程处于闲置状态，那么就会去查看异步队列中是否有任务，如果有那就执行第一个任务

#### 宏任务（macro-task）和微任务（micro-task）

宏任务包括：script(整体代码), setTimeout, setInterval, setImmediate（NodeJs）, I/O, UI rendering。
微任务包括: process.nextTick（NodeJs）, Promise, Object.observe(已废弃), MutationObserver(html5 新特性)

#### 总结

调用栈会先执行宏（队列）任务，然后当调用栈为空时（即任务执行完毕），再调用微（队列）任务，直到再次为空，再调用宏（队列）任务，以此循环
