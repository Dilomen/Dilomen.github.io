## 扁平化数组

将多重数组变成一维数组或者维度更少的数组

### 方法 1

通过 join 或者 toString 将数组的转成,分隔的字符串,缺点，数据类型都会变成字符串

```js
let arr = [1, 2, [3, 4], [5, 6, 7, [8, 9]]];
function flatten(arr) {
  let str = arr.join();
  // let str = arr.toString();
  return str.split(',');
}
```

### 方法 2

递归

```js
let arr = [1, 2, [3, 4], [5, 6, 7, [8, 9]]];
function flatten(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      res = res.concat(flatten(arr[i]));
    } else {
      res.push(arr[i]);
    }
  }
  return res;
}
```

### 方法 3

ES6 的 flat 方法,接受一个参数，改方法会根据这个参数深度进行递归遍历，如果不确定是多少层，可以使用 Infinity 作为参数

```js
arr.flat();
```

## debounce(防抖)函数

在一定时间内再次触发，会重新计算执行时间

```js
function debounce(fn, delay = 500) {
  let timer;
  return function() {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  };
}
```

## throttle(节流)函数

在一定时间内，只会执行一次函数

```js
function throttle(fn, delay) {
  let timer;
  return function(...args) {
    let last = timer;
    let now = Date.now();
    if (!last) {
      timer = now;
      fn.apply(this, args);
      return;
    }
    // 依靠now的变化，决定一段时间内只执行一次函数
    if (now - last < delay) return;
    timer = now;
    fn.apply(this, args);
  };
}

// setTimeout可能执行会大于指定的间隔时间
function throttle(fn) {
  var flag = true;
  return function(...args) {
    if (!flag) return;
    flag = false;
    fn.apply(this, args);
    setTimeout(function() {
      flag = true;
    }, 500);
  };
}
```

## bind 函数

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function() {
    let self = this;
    let context = [].shift.call(arguments);
    let args = [].slice.call(arguments);
    return function() {
      self.apply(context, [].concat(...args, [].slice.call(arguments)));
    };
  };
}
```

## 控制并发请求数量

```js
class LimitResquest {
  constructor(limit) {
    this.limit = limit;
    this.currentSum = 0;
    this.requests = [];
  }

  request(reqFn) {
    if (!reqFn || !(reqFn instanceof Function)) {
      console.error('当前请求不是一个Function', reqFn);
      return;
    }
    this.requests.push(reqFn);
    if (this.currentSum < this.limit) {
      this.run();
    }
  }

  async run() {
    try {
      ++this.currentSum;
      const fn = this.requests.shift();
      await fn();
    } catch (err) {
      console.log('Error', err);
    } finally {
      --this.currentSum;
      if (this.requests.length > 0) {
        this.run();
      }
    }
  }
}
```

## 将一个一维数组转成树结构

```js
const tree = [
  {
    id: 1,
    parentId: 0,
    name: '一级菜单A',
    rank: 1,
  },
  {
    id: 2,
    parentId: 0,
    name: '一级菜单B',
    rank: 1,
  },
  {
    id: 3,
    parentId: 0,
    name: '一级菜单C',
    rank: 1,
  },
  {
    id: 4,
    parentId: 1,
    name: '二级菜单A-1',
    rank: 2,
  },
  {
    id: 5,
    parentId: 1,
    name: '二级菜单A-2',
    rank: 2,
  },
  {
    id: 6,
    parentId: 2,
    name: '二级菜单B',
    rank: 2,
  },
  {
    id: 7,
    parentId: 4,
    name: '三级菜单A',
    rank: 3,
  },
  {
    id: 8,
    parentId: 7,
    name: '四级菜单A',
    rank: 4,
  },
  {
    id: 9,
    parentId: 8,
    name: '五级菜单A',
    rank: 5,
  },
  {
    id: 10,
    parentId: 9,
    name: '六级菜单A',
    rank: 6,
  },
  {
    id: 11,
    parentId: 10,
    name: '七级菜单A',
    rank: 7,
  },
  {
    id: 12,
    parentId: 11,
    name: '八级菜单A',
    rank: 8,
  },
  {
    id: 13,
    parentId: 12,
    name: '九级菜单A',
    rank: 9,
  },
  {
    id: 14,
    parentId: 13,
    name: '十级菜单A',
    rank: 10,
  },
];

// 复杂度 n * n
function treeData() {
  let newTree = [];
  let cloneTree = JSON.parse(JSON.stringify(tree));
  const treeLen = cloneTree.length;
  for (let i = 0; i < treeLen; i++) {
    if (cloneTree[i].parentId === 0) {
      newTree.push(cloneTree[i]);
    }
    for (let j = 0; j < treeLen; j++) {
      if (i === j) continue;
      const parent = cloneTree[i];
      const child = cloneTree[j];
      if (parent.id === child.parentId) {
        if (!parent.children) parent.children = [];
        parent.children.push(child);
      }
    }
  }
  return newTree;
}

// 复杂度 2n
function treeData(data) {
  const obj = {};
  for (let i = 0; i < data.length; i++) {
    const menuItem = data[i];
    if (!menuItem.children) menuItem.children = [];
    if (!obj[menuItem.id]) obj[menuItem.id] = menuItem;
  }

  for (let i = 0; i < data.length; i++) {
    const parentId = data[i].parentId;
    if (parentId === 0) continue;
    obj[parentId].children.push(data[i]);
  }

  return Object.values(obj).reduce((arr, value) => {
    if (value.parentId === 0) {
      arr.push(value);
    }
    return arr;
  }, []);
}
```

## 柯里化函数

柯里化函数就是将原本接受多个参数的函数变成可执行为接受部分参数，并返回接受剩下参数的新函数

```js
function add(a, b, c, d) {
  return a + b + c + d;
}
function curry(fn) {
  let argLen = fn.length, // 函数参数个数
    args = [];
  return function core() {
    let arg = [].slice.call(arguments);
    args = args.concat(arg);
    argLen -= arg.length;
    return argLen === 0 ? fn.apply(null, args) : core;
  };
}

var func = curry(add);
console.log(func(1, 2)(3));
```

```js
const curry = (fn, n = fn.length, args = []) =>
  n === 0
    ? fn(...args)
    : (...args1) => curry(fn, n - args1.length, [...args, ...args1]);
```

## 复合函数

复合函数就是将多个函数作为参数传入，然后通过每一个函数的调用，返回结果。一个函数的返回值将作为另一个函数的参数

```js
function compose() {
  const args = [...arguments];
  const len = args.length - 1;
  return function(data) {
    return args.reduceRight(function(res, cb) {
      return cb(res);
    }, data);
  };
}
```

```js
function fn1(value) => value + 1
function fn2(value) => value + 2
const composeFn = compose(fn1, fn2)
composeFn(1) // 4
```

#### 异步处理

```js
function compose() {
  const args = [...arguments];
  const len = args.length - 1;
  function tryPromiseFunc(func, ...params) {
    return new Promise((resolve, reject) => {
      try {
        const res = func(...params);
        if (res instanceof Promise) {
          res.then((data) => resolve(data)).catch((err) => reject(err));
        } else {
          resolve(res);
        }
      } catch (err) {
        reject(err);
      }
    });
  }
  return async function(data) {
    let result;
    let promiseFn = tryPromiseFunc(args[len], data);
    for (let i = len; i > 0; i--) {
      promiseFn = promiseFn.then((res) => {
        return tryPromiseFunc(args[i - 1], res);
      });
    }
    return promiseFn;
  };
}
```

#### 简单使用

```js
var fn1 = (a) => {
  new Promise((resolve) => {
    resolve(a + 1);
  });
};

var fn2 = (a) => a + 2;
var fn3 = (a) => {
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(a + 3);
    });
  });
};

const composeFn = compose(fn1, fn2, fn3);
composeFn(1).then((data) => {
  console.log(data);
});
```
