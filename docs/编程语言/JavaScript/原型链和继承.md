## JavaScript 的继承

> JavaScript 的继承和基于类的语言有所不同，它本身不提供类的概念，包括 ES6 引入的 class 也不过是语法糖，JS 的继承是通过原型来实现的

## 原型链

> 主要是利用了\_\_proto\_\_这个隐式原型将所有的继承串在了一起，实现了原型链

下面是一个 new itemTest()的实例，它的\_\_proto\_\_就指向了继承的 itemTest 的 prototype，然后再向上\_\_proto\_\_就是 test 的 prototype，而 test 的\_\_proto\_\_指向了 Object 的 prototype，由此构成了原型链，直到 Object 的父级 null ，null 没有原型，也是原型链最后一级

<a data-fancybox title="原型链" href="/JavaScript/原型链.png">![原型链](/JavaScript/原型链.png)</a>

:::tip 提示
JavaScript 中，所有的对象都是继承于 Object 的
:::

## 实例执行过程

:::tip
首先该实例对象会查找自身的属性或方法，如果不存在，那么他就会从原型链去找，一层一层的沿着原型链找，直到到顶层还没找到，就返回 null。
:::
`所以过多的原型继承也可能导致性能的损失`

## 继承父级的原型方法

```js
function test(name, age, sex) {
  this.name = name;
}
test.prototype = {
  sayName: function() {
    return this.name;
  },
};
var t = new test('zjf');
console.log(t.sayName()); //"zjf"
var t1 = new test('lll');
console.log(t1.sayName()); //"lll"
```

<a data-fancybox title="继承原型方法" href="/JavaScript/继承原型方法.png">![继承原型方法](/JavaScript/继承原型方法.png)</a>

## 修改原型

#### 由于 prototype 是一个对象，所以在修改的时候应该采取后者，前者会将这个原型对象覆盖

```js
test.prototype = {
  sayName: function() {
    return this.name;
  },
};
test.prototype.sayName = function() {
  return this.name;
};
```

#### 同时**修改 prototype 需要在创建实例之前**，因为实例对象与函数原型之间的引用关系是在创建时建立的，如果在创建实例后改变，所创建的实例继承的还是之前的原型，不会继承新的改变的原型

#### 继承原型函数的实例无法改变原型的属性和值（实例自己可以设置自己的属性和值），但是不建议这么做，不利于维护

```js
var t = new test();
t.name = 'mmm';
t.sayName = function() {
  return '111';
};
console.log(t.sayName()); // "111"
```

## prototype ，\_\_proto\_\_和 constructor 的关系

:::tip

- 每一个原型对象都有一个 constructor 指向它的构造函数，每一个实例也有
- 每一个 object 对象都有\_\_proto\_\_属性，且包括很多的方法，但只有函数对象有 prototype 属性
  :::
  <a data-fancybox title="构造函数和原型对象" href="/JavaScript/构造函数和原型对象.png">![构造函数和原型对象](/JavaScript/构造函数和原型对象.png)</a>

#### 隐式原型\_\_proto\_\_

每个对象都会有隐式原型，该属性是一个对象，每个\_\_proto\_\_里都有\_\_proto\_\_，当访问一个对象的属性或方法不存在时，它就会找下一个\_\_proto\_\_，这就形成了原型链，但它不是一个标准，标准规定可以通过 Object.getPrototypeOf()的方法来访问这个

#### 显式原型 prototype

任意一个函数（特殊的对象）都有一个显式原型 prototype，该属性就是这个对象的原型对象
test.\_\_proto\_\_ === Test.prototype

- 构造函数和原型的关系：
  Test.prototype.constructor === Test
- 实例和对象之间的关系: t.\_\_proto\_\_ === test.prototype

## 改变 constructor 的指向

```js
function test(name) {
  this.name = name;
}
test.prototype.sayName = function() {
  return this.name;
};

function itemTest(name, age) {
  // 继承父类的构造器
  test.call(this, name);
  this.age = age;
}
itemTest.prototype = new test();
console.log(itemTest.prototype.constructor); // test
```

当使用原型继承时，新的"类"的 constructor 会指向父类  
可以通过以下方式改变指向：

```js
itemTest.prototype.constructor = itemTest;
或;
Object.defineProperty(itemTest.prototype, 'constructor', {
  enumerable: false,
  value: itemTest,
  writeable: true,
});
```

## 继承构造函数的属性

```js
function Super(name) {
  this.name = name;
}
function Sub(name, age) {
  //调用构造函数
  Super.call(this, name);
  this.age = age;
}
```

class 的 super 同理

#### 确定原型和实例的关系

instanceof 操作符和 isPrototypeof 方法

## ES5 和 ES6 的继承

首先 ES6 的 class 是语法糖，即时 ES5 原型继承的封装，所以本质上是一样的，但是使用上是有区别的

- 1、ES5 中 function 声明是会声明提升的，而 class 不会
- 2、ES5 中父类和子类都是自己先声明的，而 class 中，子类必须基于 super 父类，才能生成
- 3、ES5 继承的原型链上构造函数指向父类，而 ES6 指向子类

```js
// ES5
function Parent(name) {
  this.name = name;
}
function Child(name) {
  Parent.call(this, name);
}

Child.prototype = new Parent();
const child = new Child();
console.log(child.__proto__.constructor); // ===> Parent
```

```js
// ES6
class Parent {
  constructor(name) {
    this.name = name;
  }
}

class Child extends Parent {
  constructor(name) {
    super(name);
  }
}
const child = new Child();
console.log(child.__proto__.constructor); // ===> Child
```
