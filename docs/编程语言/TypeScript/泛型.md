## 概述

泛型就是对类型的逻辑编码，可以通过其灵活性来拓展应对运行时的动态类型的变化。

## 使用

当遇到以下情况时，我们希望一个动态类型可以根据传入决定，而不需要这种多态的形式编写

```ts
function identity(arg1: Number): Number {
  return arg1;
}

function identity(arg1: String): String {
  return arg1;
}
```

```ts
const identity = <T>(arg1: T): T => {
  return arg1;
};

function identity<T>(arg1: T): T {
  return arg1;
}

identity<Number>(1);
identity<String>('1');
```

通过对泛型的约束

```ts
interface APIs {
  '/getList': { list: string; code: number };
  '/getDetail': { data: string; code: number };
}

// 还能提供更好的提示
const api = <URL extends keyof APIs>(url: URL) => {};

api('/getDetail');
```

泛型还能递归

```ts
type ListNode<T> = {
  data: T;
  next: ListNode<T> | null;
};
class Node1 {
  data: number;
  next: ListNode<number> | null;
  constructor(data: number, next: ListNode<number>['next'] = null) {
    this.data = data;
    this.next = next;
  }
}
```

## Utility Types

TS 提供了一些类型方法，用于类型转换

### -- Partial\<Type>

将所有的类型变为可选

```ts
interface IPerson {
  name: string;
  age: number;
}
/**
 * Partial<IPerson> {
 *  name?: string | undefined;
 *  age?: number | undefined;
 * }
 */
const person: Partial<IPerson> = {};
```

### -- Required\<Type>

将所有的类型变为可选

```ts
interface IPerson {
  name?: string | undefined;
  age?: number;
}
/**
 * Required<IPerson> {
 *  name: string;
 *  age: number;
 * }
 */
const person: Required<IPerson> = {
  name: 'Dilomen',
  age: 26,
};
```

### -- Readonly\<Type>

将所有属性变成只读，不可修改

```ts
interface IPerson {
  name: string;
  age: number;
}
/**
 * Readonly<IPerson> {
 *  readonly name: string;
 *  readonly age: number;
 * }
 */
const person: Readonly<IPerson> = {
  name: 'Dilomen',
  age: 26,
};

person.name = 'Alice'; // Error: it is a read-only property.
```

### -- Record\<Keys, Type>

创建一个对象类型

```ts
/**
 * Record<'name', string> {
 *  name: string;
 * }
 */
const person: Record<'name', string> = { name: 'Dilomen' };

interface IPersonInfo {
  name: string;
  age: number;
}
type Names = 'Dilome' | 'Alice';
/**
 * Record<Names, IPersonInfo> {
 *  Dilomen: IPersonInfo;
 *  Alice: IPersonInfo;
 * }
 */
const students: Record<Names, IPersonInfo> = {
  name: 'Dilomen',
  age: 26,
};
```

### -- Pick\<Type, Keys>

选择属性组成新的类型

```ts
interface IPerson {
  name: string;
  age: number;
  sex: string;
}
/**
 * Pick<IPerson, 'name' | 'age'> {
 *  name: string;
 *  age: number;
 * }
 */
const person: Pick<IPerson, 'name' | 'age'> = {
  name: 'Dilomen',
  age: 26,
};
```

### -- Omit\<Type, Keys>

排除属性组成新的类型

```ts
interface IPerson {
  name: string;
  age: number;
  sex: string;
}
/**
 * Omit<IPerson, 'name'> {
 *  name: string;
 *  sex: string;
 * }
 */
const person: Omit<IPerson, 'name'> = {
  age: 26,
  sex: 'man',
};
```

### -- Exclude\<UnionType, ExcludedMembers>

排除联合类型中的某些类型

```ts
type IUnionType = 'a' | 'b' | 'c' | 'd';
/**
 * Exclude<IUnionType, 'b'> = 'a' | 'c' | 'd';
 */
const typeExcludedB: Exclude<IUnionType, 'b'> = 'a';
```

### -- Extract\<Type, Union>

选择联合类型中的某些类型

```ts
type IUnionType = 'a' | 'b' | 'c' | 'd';
/**
 * Extract<IUnionType, 'c' | 'd'> = 'c' | 'd';
 */
const typeExtract: Extract<IUnionType, 'c' | 'd'> = 'd';
```

### -- NonNullable\<Type>

去除类型中的 null 和 undefined 定义

```ts
type IType = string | undefined | null;
/**
 * NonNullable<IType> = string;
 */
const typeNonNullable: NonNullable<IType> = 'd';
```

### -- Parameters\<Type>

将方法参数类型转换为元组

```ts
/**
 * Parameters<(arg1: string, arg2: number) => {}> = [string, number]
 */
type ParamsType = Parameters<(arg1: string, arg2: number) => {}>;
const test = (...args: ParamsType) => {};
test('1', 1);
```

### -- ConstructorParameters\<Type>

将构造函数参数类型转换为元组

```ts
interface Person {
  new (name: string, age: number): Function;
}
/**
 * ConstructorParameters<Person> = [string, number]
 */
const test = (...args: ConstructorParameters<Person>) => {};
test('1', 1);
```

### -- ReturnType\<Type>

将函数的返回类型作为一个类型

```ts
type func = (data: number) => string;
/**
 * ReturnType<func> = string
 */
const find: ReturnType<func> = 'string';
```

### -- InstanceType\<Type>

将实例类型作为一个类型

```ts
class Person {
  name = 'Dilomen';
}
/**
 * InstanceType<typeof Person> = Person;
 */
type InstanceType = InstanceType<typeof Person>;
const person: InstanceType = new Person();
```

### -- ThisType\<Type>

用作于上下文 this 标记，需在 tsconfig.json 配置 noImplicitThis 属性才能开启

```ts
const foo: { bar: any } & ThisType<{ a: number }> = {
  bar() {
    console.log(this.a); // ok
    console.log(this.b); // Error: 类型“{ a: number; }”上不存在属性“b”
  },
};
```
