---
title: React高阶组件
abbrlink: 1c14eb6a
date: 2019-11-21 21:22:31
tags:
keywords:
description:
---

> JS 函数是第一公民，其可以作为参数进行输入，也可以作为结果输出，那么在 React 中，组件也可以类似于函数，既可以作为输出，也可以作为输入

## 作用

高阶函数在 React 实质就是一个装饰器，即将原有组件增强，使代码更具复用性，逻辑性与抽象特性。可以对 props 和 state 进行控制，也可以控制组件的 render

## 实现高阶组件的方法

## 1.属性代理：高阶组件通过被包裹的 React 组件来操作 props

- 基本高阶组件

```js
const MyContainer = WrappedComponent => {
  return class extends Component {
    render() {
      return <WrappedComponent {...this.props} />;
    }
  };
};

@MyContainer
class MyComponent extends Component {
  render() {}
}
export default MyConponent;
```

- 高阶组件控制 props，为了防止修改原来的 props，最好生成新的对象

```js
const MyContainer = WrappedComponent => {
  return class extends Component {
    render() {
      // 生成一个对象
      const newProps = {
        text: newText
      };
      return <WrappedComponent {...this.props} {...newProps} />;
    }
  };
};
```

- 通过 refs 使用引用

```js
const MyRef = WrappedComponent => {
  return class extends Component {
    proc(wrappedComponentInstance) {
      wrappedComponentInstance.method();
    }
    render() {
      const props = Object.assign({}, this.props, {
        ref: this.poc.bind(this)
      });
      return <WrappedComponent {...props}></WrappedComponent>;
    }
  };
};
```

- 将组件的状态抽离出来，使组件变成展示型组件

```js
const MyContainer = WrappedComponent => {
  return class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        name: ""
      };
      this.onNameChange = this.onNameChange.bind(this);
    }

    onNameChange = event => {
      this.setState(
        {
          name: event.target.value
        },
        () => {
          console.log(this.state.name);
        }
      );
    };

    render() {
      const newProps = {
        value: this.state.name,
        onChange: this.onNameChange
      };
      return <WrappedComponent {...this.prop} {...newProps} />;
    }
  };
};
export default MyContainer;
```

## 2.反向继承：高阶组件继承于被包裹的 React 组件

- 在反向继承中，高阶组件可以使用传入组件的 state，props，render 和生命周期，但是不能保证子组件树被解析

```js
const MyContainer = WrappedComponent =>
  class extends WrappedComponent {
    render() {
      return super.render();
    }
  };
```

- 渲染劫持

```js
const MyContainer = WrappedComponent => {
  return class extends WrappedComponent {
    render() {
      if (this.props.loggedIn) {
        return super.render();
      } else {
        return null;
      }
    }
  };
};
```

- 对 render 输出结果进行修改

```js
const MyContainer = WrappedComponent => {
  return class extends WrappedComponent {
    render() {
      const elementsTree = super.render();
      let newProps = {};
      if (elementsTree && elementsTree.type === "input") {
        newProps = { value: "this is input" };
      }
      const props = Object.assign({}, elementsTree.props, newProps);
      const newElementTree = React.cloneElement(
        elementsTree,
        props,
        elementsTree.props.children
      );
      return newElementTree;
    }
  };
};
```

- 控制 state

```js
const MyReverse = WrappedComponent => {
  return class extends WrappedComponent {
    render() {
      return (
        <div>
          <h2>HOC Component</h2>
          <p>
            Props<pre>{JSON.stringify(this.props, null, 2)}</pre>
          </p>
          <p>
            State<pre>{JSON.stringify(this.state, null, 2)}</pre>
          </p>
          {super.render()}
        </div>
      );
    }
  };
};
```

## 组件参数  
如果需要传递更多的参数，可以再嵌套一层，用柯里化函数，redux 的 connect 就是这样的

```js
function MyContainer(...params) {
  return function HOCFactory(WrappedComponent) {
    return class extends WrappedComponent {
      render() {
        return <WrappedComponent {...this.props} />;
      }
    };
  };
}

MyContainer(params)(MyComponent);

@MyContainer(params)
class MyComponent extends Component {}
```
