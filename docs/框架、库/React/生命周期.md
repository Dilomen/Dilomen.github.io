## 16.3 版本前

tip:由于有些公司还是使用 16.3 版本前的生命周期，所以有必要了解下
<a data-fancybox title="16.3版本前" href="/框架/react_lifeloop.png">![16.3版本前](/框架/react_lifeloop.png)</a>

> 图片来自于<https://hackernoon.com/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0?gi=630d5f23e5a>

> 作为验证，设置了 2 个文件，Sup.js 和 Sub.js，分别是父组件和子组件

### 验证 1 自身组件的渲染

#### 不涉及父子组件，只看自身组件的渲染，也不涉及 update 的相关生命周期

在 Sup.js 编写以下代码

```js
export default class Sup extends Component {
  constructor(props) {
    super(props);
    console.log('Sup constructor');
  }
  componentWillMount() {
    console.log('Sup componentWillMount');
  }
  componentDidMount() {
    console.log('Sup componentDidMount');
  }
  render() {
    console.log('Sup render');
    return null;
  }
}
```

执行结果：

```js
Sup constructor
Sup componentWillMount
Sup render
Sup componentDidMount
```

所以步骤是：

1. 初始化 state 和 prop
2. 然后是 componentWillMount，当组件挂载到 DOM 之前
3. 然后是 render 开始渲染组件
4. 再是 componentDidMount，组件挂载到 DOM 完成

总结：

1. 在整个组件中首先加载的是初始化的 props 和 state,这两个初始化都是在构造函数中执行的，props 是构造函数通过 getDefaultProps 进行管理的，state 则是通过 getInitialState 进行初始化

2. 接着是 componentWillMount 生命周期，该生命周期在 render 之前执行，所以在此生命周期中改变 state，不会触发 re-render 重新渲染，也不推荐在此声明周期改变 state，如果是直接改变，那么和 construtor 中初始化是没有区别的，如果是调用接口这种有延迟的，那就可能会引起 render 的一直刷新，所以**不推荐在 componentWillMount 中进行 state 的改变**，平时也不太会用该生命周期

3. 最后就是 componentDidMount，也就是 DOM 挂载完成时。一般初始化接口在该生命周期中调取

4. 整个加载过程是以递归的形式，父组件先触发 componentWillMount，然后子组件触发 componentWillMount，然后载子组件触发 componentDidMount，最后父组件触发 componentDidMount，即先向下一层层执行，再向上一层层挂载，一个 V 字型

#### 看看可以做啥优化

- 讲到 react 优化，最直观的就是**减少 render 执行的次数**

- 什么会引起 render 的重新执行（渲染）呢？  
  就是 **state 或 prop 发生改变时**

- 验证（因为这里只涉及单组件，所以暂不考虑 prop，只考虑 state）

  - 首先 componentWillMount 修改 setState

    ```js
    export default class Sup extends Component {
    constructor(props) {
        super(props)
        this.state = {
            value: 0
        }
        ...
    }
    componentWillMount() {
        this.setState({
            value: 2
        })
        console.log("Sup componentWillMount")
    }
    ...
    render() {
        console.log(this.state.value)
        console.log("Sup render")
        ...
    }
    ```

    执行结果：

    ```js
    Sup componentWillMount
    2
    Sup render
    ```

    由此可得在 componentWillMount 中 setState 不会重新渲染 render，但是项目中一般不在这里进行 setState 的渲染，因为这里的 setState 和在 constructor 里做的操作是一样的，并且他们都会在组件被挂载到 DOM 前**只执行一次**

  - 修改代码（模拟调取后端接口）

    ```js
    componentWillMount() {
        setTimeout(() => {
            this.setState({
                value: 2
            })
        }, 10)
        console.log("Sup componentWillMount")
    }
    ```

    执行结果：

    ```js
    Sup componentWillMount
    0
    Sup render
    2
    Sup render
    ```

    由此可得，如果 componentWillMount 不是同步代码也会造成 render 的再次渲染，而且可能会和第一次渲染过程冲突，不是很安全

  - 接着在 componentDidMount 里写

    ```js
    export default class Sup extends Component {
    constructor(props) {
        super(props)
        this.state = {
            value: 0
        }
        ...
    }
    componentDidMount() {
        this.setState({
            value: 2
        })
        console.log("Sup componentDidMount")
    }
    ...
    render() {
        console.log(this.state.value)
        console.log("Sup render")
        ...
    }
    ```

    执行结果：

    ```js
    0
    Sup render
    Sup componentDidMount
    2
    Sup render
    ```

    由此可知在 componentDidMount 中改变 state 会引起 render 的再次渲染，因为本身该生命周期就在 render 后面，但是是不是这样就影响性能了？比较上面的 componentWillMount 里处理异步，如请求，放在这里会更安全，所以这个再次渲染是有必要的

### 验证 2：子组件的渲染

#### 查看子组件的渲染，主要是验证 update 相关的生命周期

在 Sub.js 编写

```js
export default class Sub extends Component {
  constructor(props) {
    super(props);
    console.log('Sub constructor');
  }

  componentWillMount() {
    console.log('Sub componentWillMount');
  }
  componentDidMount() {
    console.log('Sub componentDidMount');
  }
  componetWillReceiveProps(nextProps) {
    console.log('Sub componetWillReceiveProps');
  }
  shouldComponentUpdate(nextProps, nextState) {
    console.log('Sub shouldComponentUpdate');
    return true;
  }
  componentWillUpdate() {
    console.log('Sub componentWillUpdate');
  }
  componentDidUpdate() {
    console.log('Sub componentDidUpdate');
  }
  componentWillUnmount() {
    console.log('Sub componentWillUnmount');
  }
  render() {
    console.log('Sub render');
    return null;
  }
}
```

执行结果：

```js
Sup constructor
Sup componentWillMount
Sup render
Sub constructor
Sub componentWillMount
Sub render
Sub componentDidMount
Sup componentDidMount
```

#### 为啥有几个没执行

子组件的 update 相关的组件需要父组件传递的 prop 发生改变时，才会执行

由上述执行结果可知：

1. 父组件先进行状态的初始化
2. 然后是进入父组件挂载到 DOM 前
3. 父组件开始渲染到 DOM
4. 遇到了子组件，开始子组件的状态初始化
5. 子组件开始挂载到 DOM 前
6. 子组件开始渲染
7. 子组件挂载完成
8. 父组件挂载完成

#### 关于 update 的生命周期

那么如何才能执行这些生命周期呢？先来了解下这些生命周期的作用

- **componetWillReceiveProps(nextProps)**
  - 作为父级传递 prop 发生改变时触发，可以操作 props 转化为自身的 state，参数 nextProps 是父组件传给当前组件的新 props
- **shouldComponentUpdate(nextProps, nextState)**
  - 当父级传递的 prop 或自身属性 state 发生改变时触发，可以返回 boolean 值用来判断是否需要进行组件的渲染，false 就不会执行后面的组件重新渲染，true 会执行，参数 nextProps 是父组件传给当前组件的新 props，nextState 是自身改变的新 state.
  - 不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify(),这样非常影响效率，且会损害性能.
- **componentWillUpdate(nextProps, nextState)**
  - 当 prop 和 state 发生改变时触发，组件重新渲染前，参数 nextProps 是父组件传给当前组件的新 props，nextState 是自身改变的新 state
- **componentDidUpdate(prevProps, prevState)**
  - 当 prop 和 state 发生改变时触发，组件重新渲染完成，参数 prevProps 是改变前的 props，prevState 是改变前的 state

#### 在 componentDidMount 中修改 state

执行结果：

```js
...
Sub shouldComponentUpdate
Sub componentWillUpdate
Sub render
Sub componentDidUpdate
```

突然在之前的输出中多出了这几个执行，可见当 state 发生改变时

1. 会先执行 shouldComponentUpdate
2. 重新渲染前 componentWillUpdate
3. 重新渲染 render
4. 重新渲染完成 componentDidUpdate

修改 shouldComponentUpdate 为 false

```js
...
Sub shouldComponentUpdate
```

后面的就不再执行了

#### 然后修改父组件的 props 传值

```js
Sub componetWillReceiveProps
Sub shouldComponentUpdate
Sub componentWillUpdate
Sub render
Sub componentDidUpdate
```

说明 componetWillReceiveProps 确实是父组件 prop 发生改变时触发的，它还会传递一个新的 prop 作为参数，nextProps，在这个生命周期中可以将新的 props 赋值给自身的状态 state

#### ？那么为什么不能再 shouldComponentUpdate 将 props 赋值给 state

首先 prop 和 state 的改变都会触发 shouldComponentUpdate 生命周期的执行，而 componetWillReceiveProps 只会通过 prop 的改变触发，前者至少会带来 2 次及以上的渲染，所以在 componetWillReceiveProps 将 props 赋值给 state 更明智，在 shouldComponentUpdate 改变 state 还可能造成循环更新，而报错
<a data-fancybox title="1" href="https://blog.dilomen.top/image/2019-09-13.png">![1](https://blog.dilomen.top/image/2019-09-13.png)</a>

#### 看看可以做啥优化

从 shouldComponentUpdate 中一眼就是突破点，因为它可以控制后面的执行，我们可以比较 state 的新旧值或 props 的新旧值来选择是否需要渲染后面的内容

### 验证 3：组件销毁

一直没看见 componentWillUnmount 触发，那么如何才能让该生命周期触发呢

首先该生命周期是组件销毁时执行，那么什么时候回引起组件的完全销毁，暂时找不出自身销毁的路径，只能由父组件来决定

```js
...
constructor(props) {
    super(props)
    this.state = {
        isVisble: true
    }
}
componentDidMount() {
    this.setState({
        isVisble: false
    })
}
render() {
    return (
        this.state.isVisble && <Sub></Sub>
    )
}
...
```

当父组件选择不再加载该子组件的时候，该子组件的 componentWillUnmount 就会被触发，这里可以处理一些定时器的清除和清除组件内创建的 DOM 等，如果被销毁组件中还有子组件，会依次从外往里进行销毁，即**父组件先销毁（触发销毁生命周期），子组件再销毁（触发销毁生命周期）**

### 16.3 版本前总结

constructor：

- state 和 props 的初始化
- 可以处理一些函数的 this 绑定(bind)

componentWillMount：

- 组件挂载到 DOM 前
- 一般不太使用

render：

- UI 组件渲染

componetWillReceiveProps(nextProps)：

- 父组件传递的 props 发生改变时触发
- 可以在这里将新的 prop 值使用 setState 转变为自身的 state

shouldComponentUpdate(nextProps, nextState)

- 父组件的传递的 props 或自身的 state 发生变化时触发
- 可以根据前后的 prop 或 state 的值来选择是否加载后面的内容，具体返回 true 即加载，返回 false 为不加载
- 为什么不能再该生命周期中将 prop 赋值给 state

componentWillUpdate(nextProps, nextState)

- 当 prop 和 state 发生改变时触发，组件重新渲染前，参数 nextProps 是父组件传给当前组件的新 props，nextState 是自身改变的新 state

componentDidUpdate(prevProps, prevState)

- 当 prop 和 state 发生改变时触发，组件重新渲染完成，参数 prevProps 是改变前的 props，prevState 是改变前的 state

componentDidMount：

- 组件挂载到 DOM 完成
- 可以做一些接口请求，改变 state 等操作

componentWillUnMount：

- 组件被销毁时触发
- 可以清除定时器和在组件内创建的 DOM，如事件绑定等

#### 为何不能再 shouldComponentUpdate 和 componentWillUpdate 调用 this.setState 方法？

简单的说就是 setState 会触发 shouldComponentUpdate 和 componentWillUpdate 方法，然后这个方法又执行了 setState 方法，就陷入了一种**死循环** ，使浏览器崩溃

## 16.3 版本后

> 引入了两个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate

:::tip
**为什么要引入这两个新的生命周期**  
由于 React 采用了一种叫 Fiber 的机制，导致原来的生命周期 componentWillMount componentWillReceiveProps componentWillUpdate 不在安全，会存在**执行期间被打断**的可能，导致执行多次的问题
:::

### getDerivedStateFromProps

> **16.4 版本前，该生命周期只会通过 props 触发，16.4 版本之后 state 和 props 的改变都会触发该生命周期**

<a data-fancybox title="16.4版本之后" href="/框架/react_lifeloop_16.4.png">![16.4版本之后](/框架/react_lifeloop_16.4.png)</a>

> 图片来自于<https://blog.csdn.net/juzipidemimi/article/details/80726308?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-24&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-24>

:::tip

**getDerivedStateFromProps 将取代以下生命周期的功能**

- componentWillReceiveProps
- componentWillMount
- componentWillUpdate
  :::

<a data-fancybox title="2" href="https://blog.dilomen.top/image/20190308160844547.png">![2](https://blog.dilomen.top/image/20190308160844547.png)</a>

它应该返回一个对象来更新状态，或者返回 null 来不更新任何内容

```js
static getDerivedStateFromProps(nextProps, prevState) {
    const {type} = nextProps;
    // 当传入的type发生变化的时候，更新state
    if (type !== prevState.type) {
        return {
            type,
        };
    }
    // 否则，对于state不进行任何操作
    return null;
}
```

也可以这样写，这样就可以获取到之前的 props，然后返回整个 state

```js
...
this.state = {
      _self: this
}
...
static getDerivedStateFromProps(nextProps, prevState) {
    let nextState = { ...prevState, prevProps: prevState._self.props };
    // prevProps, nextProps, prevState, nextState
    console.log(nextState.prevProps, nextProps, prevState, nextState)
    let id = Number(nextProps.id)
    if (id !== prevState.contactType) {
      nextState.contactType = id;
    }
    return nextState
  }

...
```

### getSnapshotBeforeUpdate

被调用于 render 之后，可以读取但无法使用 DOM 的时候。它使您的组件可以在可能更改之前从 DOM 捕获一些信息（例如滚动位置）
此生命周期返回的任何值都将作为参数传递给 componentDidUpdate,所以当写有 getSnapshotBeforeUpdate 生命周期时，也必须写 componentDidUpdate

```js
getSnapshotBeforeUpdate() {
    return {a: 1}
}
componentDidUpdate(prevProps, prevState, snapshot) {
    console.log(prevProps, prevState, snapshot)
}
```

componentDidUpdate 的第三个参数便是 getSnapshotBeforeUpdate 返回的{a: 1}

常常用于 scroll 位置的定位

```js
class ScrollingList extends React.Component {
  constructor(props) {
    super(props);
    // 取得dom 节点
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 根据新添加的元素来计算得到所需要滚动的位置
    if (prevProps.list.length < this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // 根据 snapshot 计算得到偏移量，得到最终滚动位置
    if (snapshot !== null) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }

  render() {
    return <div ref={this.listRef}>{/* ...contents... */}</div>;
  }
}
```

> 参考文章： https://www.jianshu.com/p/514fe21b9914

### componentDidCatch

此生命周期在后代组件抛出错误后被调用

错误边界无法捕获以下场景中产生的错误

- 事件处理：因为它不是在渲染期间执行的，可以使用 try-catch 来处理
- 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）
- 服务端渲染
- 它自身抛出来的错误（并非它的子组件）

```js
// error抛出的错误，info带有componentStack Key
componentDidCatch(error, info) {
  // 可以将错误日志报给服务器进行处理
  logErrorToMyService(error, errorInfo);
}
```

```js
// 捕获错误
componentDidCatch(error, errorInfo) {
  ...
}

render() {
  if (this.state.counter === 5) {
    throw new Error('I crashed!');
  }
  return ...;
}
```
