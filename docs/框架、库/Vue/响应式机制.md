## 概述

Vue 的响应式机制是相对于别的框架所比较特别的一种数据驱动视图的解决方式，其主要采用了原生的 Object.defineProperty 中带有的 get 和 set 来进行对对象属性的监听。

> 转载于官网
> <a data-fancybox title=""Vue响应式图解"" href="/框架/Vue响应式图解.png">!["Vue响应式图解"](/框架/Vue响应式图解.png)</a>

由图可以清晰的可得：当视图改变了数据 Data 的，那么 Data 会通过绑定的 setter 通知 Watcher（发布者），做出对应的组件渲染，然后渲染到虚拟 DOM，最终转成真实 DOM，改变视图。

**官网解释**：<em>每一个组件实例对应一个 watcher</em>，当组件渲染的过程中使用到的数据记录为依赖，即进行"监听"（setter 监听对象属性），当依赖被触发时（即数据被改变了），就会通知 watcher，从而将对应关联的组件重新渲染。

## 新属性的注意事项

官网指出，Vue 不能检测到数组和对象的的变化，即如果我们添加了新的属性和数组的项，Vue 不能做出对应的响应。

这是因为当初始化数据 data 时，Vue 会对 data 中的属性进行递归设为<em>"依赖"</em>，但是后面添加的属性或者子项，是没有被设为依赖的，所以无法对其进行监听。
需要通过手动的方式，即使用 Vue 提供的 this.\$set 来设置属性和对象的联系

```js
data() {
  return {
    obj: {
      a: 1
    }
  }
}
this.$set(this.obj, 'b', 2)
```

数组也是同样，如果对已经绑定的依赖的索引进行改变是会被触发的，但是新添加的索引不会有响应式，也需要手动绑定

```js
data() {
  return {
    arr: [1,2,3]
  }
}
this.$set(this.obj, 5, 2)
```

**Vue 对数组的处理**
但是往往我们在使用数组的原型方法时，发现数组是又被触发的，而根本不需要手动绑定。  
这里首先要区分一下这些方法是否对原数组的子项进行了改变，如 unshift 方法就把所有的原先子项索引都往后移了，那么自然而然会去触发对应的响应。但是像 push 这种，在数组尾部添加的，就不能触发对应的响应了

```js
var arr = [1, 2];
// !!!这里只是做了一个简单的例子，其实Vue出于性能的考虑，并不会对一个数组的每一个子项进行监听
arr.forEach((item, index) => {
  Object.defineProperty(arr, index, {
    get() {
      console.log('get');
    },
    set(val) {
      console.log('set', val);
    },
  });
});
arr.unshift(3); // 做出了响应
arr.push(3); // 没有做出响应
```

可是当我们在 vue 项目中使用 push 的时候明明做出了响应呀？

可以看到 Vue 源码中，是将这几个数组方法有 hack（重写）处理的，会主动是通知 watcher 做出响应

```js
if (Array.isArray(value)) {
  if (hasProto) {
    // 将hack的数组方法写到数组的原型上
    protoAugment(value, arrayMethods);
  } else {
    copyAugment(value, arrayMethods, arrayKeys);
  }
  this.observeArray(value);
} else {
  this.walk(value);
}
```

```js
let inserted;
// 对于一些新增加索引的方法，进行了新索引的监听
switch (method) {
  case 'push':
  case 'unshift':
    inserted = args;
    break;
  case 'splice':
    inserted = args.slice(2);
    break;
}
if (inserted) ob.observeArray(inserted);
// notify change
ob.dep.notify();
```

总之，在 Vue3.0 采用了 proxy 之后，这也将不再是问题，因为 proxy 是对整个对象进行监听，而不需要对每一个属性监听

```js
var arr = [1,2]
var handler = {
  get(obj, props) {
    console.log('proxy get')
    return props in obj ? obj[props] : undefined
  },
  set(obj, prop, value) {
    console.log('proxy set')
    // 必须返回true，表示成功
    return true
  }
}
var proxy = new Proxy(arr, handler)
proxy.push(5)
proxy[5] = 4
```

## 异步渲染

Vue 的数据渲染视图是异步的，首先改变的数据会被放到<em>异步队列</em>，Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。然后在某个时刻一起更新 DOM，也是 Vue 提升性能的一种处理方式。

我们可以通过 Vue 提供的\$nextTick 来处理 DOM 更新后的回调

```js
// 可以直接使用回调函数
this.$nextTick(() => {
  console.log(this.$refs.list.childNodes.length);
});
// 也支持Promise
this.$nextTick().then(() => console.log(this.$refs.list.childNodes.length));
await this.$nextTick();
console.log(this.$refs.list.childNodes.length);
```
