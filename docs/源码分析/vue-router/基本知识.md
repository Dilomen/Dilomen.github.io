## 概述

vue-router 是为 vue 单页面应用实现一种不请求后端的前端路由跳转方式

## install

首先从 Vue 的注册插件方式入手，Vue 官方提供 use 方法来导入插件，要求是插件必须提供 install 方法，以被 Vue 调用

```js
import VueRouter from 'vue-router';
Vue.use(VueRouter);
```

从 index.js 中可以看到，vue-router 只提供了一个 version 版本属性和一个 install 方法作为静态直接可调用对象

```js
VueRouter.install = install;
VueRouter.version = '__VERSION__';
```

### install 做了什么

首先 install 接受 Vue 相应的处理调用，接受 Vue 实例参数

调用 Vue 的混入，对在 router 范围内的组件都进行生命周期的修改

```js
Vue.mixin({
  beforeCreate() {
    // ...
  },
  destroyed() {
    // ...
  },
});
```

然后是监听了 Vue.prototype 上的$router和$route 属性

```js
Object.defineProperty(Vue.prototype, '$router', {
  get() {
    return this._routerRoot._router;
  },
});

Object.defineProperty(Vue.prototype, '$route', {
  get() {
    return this._routerRoot._route;
  },
});
```

## 创建 2 个组件

```js
Vue.component('RouterView', View);
Vue.component('RouterLink', Link);
```

## 回到入口文件 index.js

这里接受我们配置的 route 信息

```js
new VueRoute({
  mode: 'hash',
  routes: [
    // ...
  ],
});
```

根据 mode 配置，生成对应的路由解决方式

```js
switch (mode) {
  case 'history':
    this.history = new HTML5History(this, options.base);
    break;
  case 'hash':
    this.history = new HashHistory(this, options.base, this.fallback);
    break;
  case 'abstract':
    this.history = new AbstractHistory(this, options.base);
    break;
  default:
    if (process.env.NODE_ENV !== 'production') {
      assert(false, `invalid mode: ${mode}`);
    }
}
```

以及各种原型方法以共调用

```js
addRoutes: ƒ addRoutes(routes)
afterEach: ƒ afterEach(fn)
back: ƒ back()
beforeEach: ƒ beforeEach(fn)
beforeResolve: ƒ beforeResolve(fn)
forward: ƒ forward()
getMatchedComponents: ƒ getMatchedComponents(to)
go: ƒ go(n)
init: ƒ init(app /* Vue component instance */)
match: ƒ match( raw, current, redirectedFrom )
onError: ƒ onError(errorCb)
onReady: ƒ onReady(cb, errorCb)
push: ƒ push(location, onComplete, onAbort)
replace: ƒ replace(location, onComplete, onAbort)
resolve: ƒ resolve( to, current, append )
```

这种主要讲下 afterEach，beforeResolve，beforeEach 的处理

首先它是将我们配置的函数，加入到队列

```js
   const queue: Array<?NavigationGuard> = [].concat(
      // in-component leave guards
      extractLeaveGuards(deactivated),
      // global before hooks
      this.router.beforeHooks,
      // in-component update hooks
      extractUpdateHooks(updated),
      // in-config enter guards
      activated.map(m => m.beforeEnter),
      // async components
      resolveAsyncComponents(activated)
    )
    // 递归的跑整个队列，直到没有
    runQueue(queue, iterator, () => {

    })
  }

  requeue
```

> 2020.06.04 星期四
