## 概述

Vue 的模板写法一向是其的特色，其极大的方便开发者平缓的学习路线，不需要学习类似 JSX 等语法。同样的模板编译也是 Vue 做提升性能的很大的一块内容，所以了解其内部的解析，能让我们更加的了解 Vue 的本质。

首先在执行运行机制篇章，有讲到运行版和完整版，两者的区别就是打包的 vue 文件是否有当前篇章的内容——模板编译。当然这里的模板编译只讲 vue 中的编译实现，也就是完整版中的模板实现原理，至于运行版依赖的 vue-loader 中的模板实现，不在本篇章的范围内，所以不再具体展开。

但是还是需要提到和本文相关的 vue-loader 部分，具体详情请看下面的 vue-loader

## 执行位置

既然是完整版，那么就从完整版入口文件开始查看，可以在挂载阶段前生成 render 函数的源码中找到

```js
// vue/src/platforms/web/entry-runtime-with-compiler.js
import { compileToFunctions } from './compiler/index';
Vue.prototype.$mount = function(el?: string | Element, hydrating?: boolean) {
  // ...
  const { render, staticRenderFns } = compileToFunctions(template, {}, this);
  // ...
};

// vue/src/platforms/web/compiler/index.js
import { createCompiler } from 'compiler/index';

const { compile, compileToFunctions } = createCompiler(baseOptions);
```

然后再从以上代码信息，我们最终追溯到了 createCompiler 方法，是的这个方法包含了整个编译模板的操作

```js
// src/compiler/index.js
export const createCompiler = createCompilerCreator(function baseCompile(
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  const code = generate(ast, options);
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns,
  };
});
```

传入了一个模板以及相关配置，然后根据模板内容生成 ast

```js
const ast = parse(template.trim(), options);
```

如果开启了 optimize 属性，那么就需要进行优化代码性能操作

```js
if (options.optimize !== false) {
  optimize(ast, options);
}
```

最终根据模板内容和配置生成代码，导出一份是静态 render 函数集合（就是没有动态数据的节点），一份是 render 函数，以及 ast

```js
const code = generate(ast, options);
return {
  ast,
  render: code.render,
  staticRenderFns: code.staticRenderFns,
};
```

:::tip staticRenderFns 是什么
staticRenderFns 是什么就是将没有动态数据的节点都存到这个数组中

这里生成的代码 code 是渲染函数 render 以及静态渲染函数 staticRenderFns(如果全是 HTML 静态节点就生成 staticRenderFns)

比如以下的模板，span 节点从开始到结束都没有动态的数据，那么这一段就会被添加到 staticRenderFns，而有动态的 div 节点就不会

```html
<div>
  <span><b>1</b></span
  >{{ msg }}
</div>
```

<a data-fancybox title="生成render" href="/源码/vue源码/模板编译/生成render.png">![生成render](/源码/vue源码/模板编译/生成render.png)</a>

具体静态节点是如何加入 staticRenderFns 及使用的，请看下面的详情 genStatic 方法
:::

那么我们就根据上面的 3 个步骤开展源码的解析

## 生成 AST

首先从 parse 中可以看出主要是执行了 parseHTML 的方法

```js
// vue/src/compiler/parser/index.js
export function parse () {
  let root
  // ...
  parseHTML() {}
  return root
}
```

### parseHTML

可以看出 parseHTML 主要是对整个模板字符串进行 while 循环，一段一段的通过正则匹配来确定是什么节点元素

```js
export function parseHTML(html, options) {
  let index = 0;
  while (html) {
    // ...
  }
}
```

### 注释节点

如果第一个字符是\<并且匹配注释的正则，那么该节点就是注释节点，然后找到注释节点结尾的位置，就是匹配到-->的位置  
如果需要保留注释，那么就调用传入的 comment 方法（具体看下面的监听方法知识部分），将整段注释作为参数  
然后在将游标指向注释节点的后面，即已经被分析过的部分就被截取掉了

```js
let textEnd = html.indexOf('<');
if (textEnd === 0) {
  // Comment:
  if (comment.test(html)) {
    const commentEnd = html.indexOf('-->');

    if (commentEnd >= 0) {
      if (options.shouldKeepComment) {
        options.comment(
          html.substring(4, commentEnd),
          index,
          index + commentEnd + 3
        );
      }
      advance(commentEnd + 3);
      continue;
    }
  }
}
```

:::tip 截取方法 advance
就是将 indexindex 是作为游标，从零开始向后移动，指向字符串的当前位置，即去掉已经分析过的模板字符串内容

```js
function advance(n) {
  index += n;
  html = html.substring(n);
}
```

:::

如果配置到 conditionalComment 的正则，那就是条件注释，如<![ IE ]>等，同样也将其截取，然后进行下面的模板分析

```js
const conditionalComment = /^<!\[/;
if (conditionalComment.test(html)) {
  const conditionalEnd = html.indexOf(']>');
  if (conditionalEnd >= 0) {
    advance(conditionalEnd + 2);
    continue;
  }
}
```

如果匹配到了 doctype 的正则，那就是文档节点

```js
const doctype = /^<!DOCTYPE [^>]+>/i;
// Doctype:
const doctypeMatch = html.match(doctype);
if (doctypeMatch) {
  advance(doctypeMatch[0].length);
  continue;
}
```

### 开始元素标签

虽然按源码顺序是先看结束元素标签，但是如果先讲开始元素标签才是正确顺序，毕竟有开始才有结束

```js
// Start tag:
const startTagMatch = parseStartTag();
if (startTagMatch) {
  handleStartTag(startTagMatch);
  if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
    advance(1);
  }
  continue;
}
```

首先会执行 parseStartTag 方法，该方法主要是看能不能根据正则匹配到开始标签，然后返回开始标签，包含标签名，开始结束位置，属性，<em>是否是自闭合标签</em>

```js
const startTagMatch = parseStartTag();
```

```js
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`;
const qnameCapture = `((?:${ncname}\\:)?${ncname})`;
const startTagOpen = new RegExp(`^<${qnameCapture}`);
const startTagClose = /^\s*(\/?)>/;

function parseStartTag() {
  // console.log(`<Button>Hello World</Button>`.match(startTagOpen))
  // ["<Button", "Button", index: 0, input: "<Button>Hello World</Button>", groups: undefined]
  const start = html.match(startTagOpen);
  if (start) {
    const match = {
      tagName: start[1],
      attrs: [],
      start: index,
    };

    let end, attr;
    // 如果没有匹配到结束标识，并匹配到属性的话，就开始添加记录attrs属性
    while (
      !(end = html.match(startTagClose)) &&
      (attr = html.match(dynamicArgAttribute) || html.match(attribute))
    ) {
      attr.start = index;
      advance(attr[0].length);
      attr.end = index;
      match.attrs.push(attr);
    }
    // 根据正则匹配，如果是自闭合元素end[1]就是'/'，如果不是就是''，以此来判断是否是自闭合元素
    // console.log('>'.match(startTagClose))  // [">", "", index: 0, input: ">", groups: undefined]
    // console.log('/>'.match(startTagClose))  // ["/>", "/", index: 0, input: "/>", groups: undefined]
    if (end) {
      match.unarySlash = end[1];
      advance(end[0].length);
      match.end = index;
      return match;
    }
  }
}
```

#### handleStartTag

如果 parseStartTag 返回由内容，就说明确实是开始标签元素，那么就执行 handleStartTag 方法

首先先看返回的结构例子，也就是 handleStartTag 的实参

```js
match: {
  tagName: Button,
  attrs: [["class="a"", "class", "=", "a", undefined, undefined, index: 0, input: "class="a">Hello World</button>", groups: undefined, start: 27, end: 36]],
  start: 23,
  end: 26
}
```

有代码可见，主要是对属性进行了包装，以及加入了“标签栈”，直至找到对应的结束标签才能出栈，这样也能保证父子标签的嵌套关系，最后调用 start 方法

```js
function handleStartTag(match) {
  const tagName = match.tagName;
  const unarySlash = match.unarySlash;

  const unary = isUnaryTag(tagName) || !!unarySlash;

  const l = match.attrs.length;
  const attrs = new Array(l);
  for (let i = 0; i < l; i++) {
    // ...
    attrs[i] = {
      name: args[1],
      value: decodeAttr(value, shouldDecodeNewlines),
    };
  }
  // 如果不是自闭合标签，就将该元素标签入栈，直至找到对应的结束标签，才能出栈
  if (!unary) {
    stack.push({
      tag: tagName,
      lowerCasedTag: tagName.toLowerCase(),
      attrs: attrs,
      start: match.start,
      end: match.end,
    });
    lastTag = tagName;
  }
  // 调用start监听函数，创建标签AST
  if (options.start) {
    options.start(tagName, attrs, unary, match.start, match.end);
  }
}
```

### 结束元素标签

首先也是根据结束的正则来进行 match 匹配，来获取元素名称，然后调用了 parseEndTag 方法

```js
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`;
const qnameCapture = `((?:${ncname}\\:)?${ncname})`;
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`);

export function parseHTML(html, options) {
  while (html) {
    if (textEnd === 0) {
      // ...
      // End tag:
      const endTagMatch = html.match(endTag);
      if (endTagMatch) {
        const curIndex = index;
        advance(endTagMatch[0].length);
        parseEndTag(endTagMatch[1], curIndex, index);
        continue;
      }
    }
  }
}
```

测试

```js
`</Button>Hello World</Button>`.match(endTag)
["</Button>", "Button", index: 0, input: "</Button>Hello World</Button>", groups: undefined]
```

#### parseEndTag

首先会将标签变成小写，然后在之前开始标签的加入的“标签栈”中找到对应的开始标签，这样就有始有终，表示一个完整的标签内容，那么在栈中，开始标签和结束标签之间的都会被作为完整的标签，所以会循环，调用 end 监听方法

```js
function parseEndTag(tagName, start, end) {
  let pos, lowerCasedTagName;
  if (start == null) start = index;
  if (end == null) end = index;

  // Find the closest opened tag of the same type
  if (tagName) {
    lowerCasedTagName = tagName.toLowerCase();
    for (pos = stack.length - 1; pos >= 0; pos--) {
      if (stack[pos].lowerCasedTag === lowerCasedTagName) {
        break;
      }
    }
  } else {
    // If no tag name is provided, clean shop
    pos = 0;
  }

  if (pos >= 0) {
    // Close all the open elements, up the stack
    for (let i = stack.length - 1; i >= pos; i--) {
      if (options.end) {
        // 出栈，每一项调用end监听方法
        options.end(stack[i].tag, start, end);
      }
    }

    // 通过length的设置，将栈中完整的标签都移除了，即将栈指针指向匹配到的开始标签之前
    stack.length = pos;
    lastTag = pos && stack[pos - 1].tag;
  }
}
```

如果是\</br>和\</p>特殊标签，作为开始标签，即调用 start 监听方法，p 标签同时也要调用 end 监听方法

- \</br>会被浏览器转化为\<br>
- \</p>会被浏览器转化为\<p></p>

```js
else if (lowerCasedTagName === 'br') {
  if (options.start) {
    options.start(tagName, [], true, start, end)
  }
} else if (lowerCasedTagName === 'p') {
  if (options.start) {
    options.start(tagName, [], false, start, end)
  }
  if (options.end) {
    options.end(tagName, start, end)
  }
}
```

```js
`/>`.match(startTagClose)
["/>", "/", index: 0, input: "/>", groups: undefined]
```

:::tip 层级关系

我们可以观察到，在整个 html 字符串的解析中，有一个 stack 的变量，一旦遇到开始元素，就入栈操作，而遇到结束元素，就进行出栈操作，由此当包装一个 AST 节点时，可以根据当前 stack 栈的前一个子项来得知其父元素

同时这种方式也能保证没有节点都有开始和结束，即便是自闭合元素，在匹配到\/>也会进行出栈操作，从而保证每个元素都是完整的，一旦有不完整的就可以进行警告提醒

#### 示例实验

```js
<div><ele-button></ele-button><p class="text">12345</p></div>
// ========>
const ast = {
  attrsList: []
  attrsMap: {}
  children: [{
    attrsList: [],
    attrsMap: {},
    children: [],
    end: 30,
    parent: {type: 1, tag: "div", attrsList: Array(0), attrsMap: {…}, rawAttrsMap: {…}, …},
    plain: true,
    rawAttrsMap: {},
    start: 5,
    tag: "ele-button",
    type: 1
  }, {
    attrsList: [],
    attrsMap: {class: "text"},
    children: [{…}],
    end: 55,
    parent: {type: 1, tag: "div", attrsList: Array(0), attrsMap: {…}, rawAttrsMap: {…}, …},
    plain: false,
    rawAttrsMap: {class: {name: "class", value: "text", start: 33, end: 45}},
    start: 30,
    staticClass: ""text"",
    tag: "p",
    type: 1,
    length: 2
  }],
  end: 61
  parent: undefined
  plain: true
  rawAttrsMap: {}
  start: 0
  tag: "div"
  type: 1
}
```

可以看出，父元素使用了 children 属性包裹了子元素，子元素使用了 parent 指向了父元素
:::

### 文本节点

如果第一个不是\<，并且字符串中前面几种情况都没有匹配到，那么就是文本节点

```js
if (textEnd === 0) {
  // 都没有匹配到
}
let text, rest, next;
if (textEnd >= 0) {
  rest = html.slice(textEnd);
  // 当匹配的<后面匹配不上结束标签、开始标签、注释节点、条件节点，那么它就是文本节点中的部分
  while (
    !endTag.test(rest) &&
    !startTagOpen.test(rest) &&
    !comment.test(rest) &&
    !conditionalComment.test(rest)
  ) {
    // 查看之后时候还有<，即获取整段文本的内容
    next = rest.indexOf('<', 1);
    if (next < 0) break;
    textEnd += next;
    rest = html.slice(textEnd);
  }

  text = html.substring(0, textEnd);
}
// 如果整个字符串匹配不到<，那么整个字符串就是文本节点
if (textEnd < 0) {
  text = html;
}
// 触发chars监听方法
if (options.chars && text) {
  options.chars(text, index - text.length, index);
}
```

如果是 script,style,textarea 等标签

```js
while (html) {
  last = html;
  // export const isPlainTextElement = makeMap('script,style,textarea', true)
  // 不是脚本script/样式style,textarea等标签
  if (!lastTag || !isPlainTextElement(lastTag)) {
    // 如果是脚本script/样式style,textarea等标签
  } else {
    // ...
    const rest = html.replace(reStackedTag, function(all, text, endTag) {
      // script,style,textarea标签内的内容直接当做文本处理
      if (options.chars) {
        options.chars(text);
      }
      return '';
    });
    index += html.length - rest.length;
    html = rest;
    parseEndTag(stackedTag, index - endTagLength, index);
  }
}
```

如果整个下来，什么也没变，那么就将整个 html 作为文本处理

```js
if (html === last) {
  options.chars && options.chars(html);
}
```

### 监听方法

上面各种匹配到相关的标签，就会调用监听方法，这些监听方法也是将 template 字符串转成 AST 的关键，分别对标签开始、标签结束、遇到文本节点、遇到注释节点等所做出不同的处理方式

```js
// src/compiler/parser/index.js
export function parse(
  template: string,
  options: CompilerOptions
): ASTElement | void {
  //...
  parseHTML(template, {
    // ...
    // 标签开始时调用
    start(tag, attrs, unary, start, end) {},
    // 标签结束时调用
    end(tag, start, end) {},
    // 遇到文本时调用
    chars(text: string, start: number, end: number) {},
    // 遇到注释时调用
    comment(text: string, start, end) {},
  });
  return root;
}
```

#### start

根据开始标签调用，然后由相关参数信息获取来创建一个 AST 节点，并根据 AST 中的信息，来转化一些信息的标识，如是否带有 v-if，v-once，slot 等，并对这些特殊的指令或者属性进行转换成 AST 对象节点上的属性，从而方便后面的使用

```js
start (tag, attrs, unary, start, end) {
  let element: ASTElement = createASTElement(tag, attrs, currentParent)
  // ...
}
// ASTElement
{
  type: 1,
  tag,
  attrsList: attrs,
  attrsMap: {},
  rawAttrsMap: {},
  parent,
  children: []
}
```

对于一些特殊的属性或指令，如 v-for，v-if 进行值的正则匹配，如果没有匹配上，那么就说明值有问题，进行警告

```js
if (inVPre) {
  processRawAttrs(element);
} else if (!element.processed) {
  processFor(element);
  processIf(element);
  processOnce(element);
}
```

如果匹配上了那么就在 AST 节点上添加特别的属性，如 v-once 就是 once:true，v-for 就是 alias 和 for 属性
<a data-fancybox title="/源码/vue源码/模板编译/ast添加指令属性.png" href="/源码/vue源码/模板编译/ast添加指令属性.png">![/源码/vue源码/模板编译/ast添加指令属性.png](/源码/vue源码/模板编译/ast添加指令属性.png)</a>

还有就是是否是自闭合节点

- 是：说明是不带子元素的，所以生成 AST 后，就可以退出“标签栈”了，
- 不是：加入“标签栈”，等待相应的结束标签来匹配

```js
start (tag, attrs, unary, start, end) {
  // 是否是自动闭合的元素
  if (!unary) {
    currentParent = element
    // 方便end函数调用的时候获取，并处理
    stack.push(element)
  } else {
    closeElement(element)
  }
}
```

#### end

当遇到结束标签的时候会调用，表示一个元素节点的关闭，完结，其主要是将“标签栈”回到上一个父节点  
[祖先元素,父元素,elementTag,elementTag 子元素] ==> [祖先元素,父元素]  
该元素标签结束，也说明其子元素都结束了

```js
end (tag, start, end) {
  const element = stack[stack.length - 1]
  stack.length -= 1
  currentParent = stack[stack.length - 1]
  if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
    element.end = end
  }
  closeElement(element)
}
```

#### chars

主要是当遇到文本节点的时候调用，根据是否带有动态变量来进行生成不同的 AST 节点

有变量的动态文本: parseText:处理带有变量的文本，如果没有变量，即纯静态文本，则返回 undefined，由此来判断时候带有变量

parseText 方法来获取动态变量信息，如果存在就会返回 expression 和 tokens 字段

```js
chars (text: string, start: number, end: number) {
  // ...
  if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
    child = {
      type: 2,
      expression: res.expression,
      tokens: res.tokens,
      text
    }
  }
}
```

如以下的模板会得到以下动态信息

```js
template: '<div><span>2222{{ msg }}</span></div>',
```

<a data-fancybox title="/源码/vue源码/模板编译/获取文本节点的动态信息.png" href="/源码/vue源码/模板编译/获取文本节点的动态信息.png">![/源码/vue源码/模板编译/获取文本节点的动态信息.png](/源码/vue源码/模板编译/获取文本节点的动态信息.png)</a>

如果 parseText 没有返回，那么就是纯文本

```js
child = {
  type: 3,
  text,
};
```

#### parseText

将文本中带有的动态变量进行包装处理

```js
// src/compiler/parser/text-parser.js
/**
 * text 传入的文本字符串内容
 * 变量的符号定义，一般默认是是 {{ value }}，但是也可以设置自定义的如%value%等，那么delimiters就是['%', '%']
 */
export function parseText(
  text: string,
  delimiters?: [string, string]
): TextParseResult | void {
  // 匹配变量，如果有自定义的如%，就选择自定义的，没有就是默认的{{}}
  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  // 如果没有匹配到，即是纯文本内容，那么就返回undefined
  if (!tagRE.test(text)) {
    return;
  }
  const tokens = [];
  const rawTokens = [];
  let lastIndex = (tagRE.lastIndex = 0);
  let match, index, tokenValue;
  // 获取到动态变量字符串的位置，一旦后面还有变量就继续，即处理所有的变量
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // 先添加变量字符串前的纯文本内容到rawTokens和tokens两个数组内
    if (index > lastIndex) {
      rawTokens.push((tokenValue = text.slice(lastIndex, index)));
      tokens.push(JSON.stringify(tokenValue));
    }
    // 然后将动态变量进行转化，tokens添加 _s({变量})， rawTokens添加 { '@binding': 变量 }
    const exp = parseFilters(match[1].trim());
    tokens.push(`_s(${exp})`);
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  // 如果后面还有内容，那就都是纯文本内容，直接加入到数组中
  if (lastIndex < text.length) {
    rawTokens.push((tokenValue = text.slice(lastIndex)));
    tokens.push(JSON.stringify(tokenValue));
  }
  // 最终形成
  // {
  //   expression: `纯文本+${_s({变量})}+纯文本`,
  //   tokens: ['纯文本', { '@binding': 变量 }, '纯文本']
  // }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens,
  };
}
```

:::tip delimiters 的处理

```js
// 如果自定义的符号delimiters中包含以下正则，即一些敏感符号就会被vue进行替换，以便不会出现内容上的混乱
const regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
const buildRegex = cached((delimiters) => {
  const open = delimiters[0].replace(regexEscapeRE, '\\$&');
  const close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});
```

:::

#### comment

生成注释节点，注释节点和纯文本节点一样，只是多一个 isComment 的属性标识

```js
comment (text: string, start, end) {
  const child: ASTText = {
    type: 3,
    text,
    isComment: true
  }
}
```

## 优化代码

主要是对一些静态节点进行优化，通过检测节点，是静态节点的话就打上静态标签，以减少不必要的重新渲染

```js
// src/compiler/index.js
export const createCompiler = createCompilerCreator(function baseCompile(
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 模板转AST相关
  if (options.optimize !== false) {
    // 优化代码是对处理后的AST节点进行优化
    optimize(ast, options);
  }
});
```

以下就是优化的整个方法，一个是打上静态标记，一个是打上根静态标记

```js
// src/compiler/optimizer.js
export function optimize(root: ?ASTElement, options: CompilerOptions) {
  if (!root) return;
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  markStatic(root);
  markStaticRoots(root, false);
}
```

定义静态的属性，即 options.staticKeys（type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap,自己配置的静态节点）等标签都是静态属性

```js
isStaticKey = genStaticKeysCached(options.staticKeys || '');
```

### markStatic

```js
function markStatic(node: ASTNode) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return;
    }
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i];
      markStatic(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block;
        markStatic(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}
```

isStatic：判断当前节点是否是静态节点
1、如果是含有动态节点的文本，直接 false
2、如果是纯文本就是 true
3、如果是带有 v-pre 指令，或者（没有绑定变量，元素上没有如 v-if，v-for 等逻辑指令，不是组件，所有属性都是静态属性），返回 true

```js
node.static = isStatic(node);
```

如果子节点，递归对子节点同样进行静态判定，如果一旦子节点不是静态的，那么父节点也不是静态的

```js
for (let i = 0, l = node.children.length; i < l; i++) {
  const child = node.children[i];
  markStatic(child);
  if (!child.static) {
    node.static = false;
  }
}
```

如果元素有 v-if 等条件判断，就需要对所有的条件子节点（v-if,v-else,v-else-if）等进行获取 block 信息然后静态判定，一旦有非静态节点，那么父节点也不是静态节点

```js
if (node.ifConditions) {
  for (let i = 1, l = node.ifConditions.length; i < l; i++) {
    const block = node.ifConditions[i].block;
    markStatic(block);
    if (!block.static) {
      node.static = false;
    }
  }
}
```

### markStaticRoots

首先如果是静态节点或者是有 v-once 的节点，那么添加一个 staticInFor 的属性为 isInFor

```js
if (node.static || node.once) {
  node.staticInFor = isInFor;
}
```

isInFor 是指是否是 v-for 下的节点，只有当节点含有 v-for，那么它的子节点的 isInFor 才是 true

```js
for (let i = 0, l = node.children.length; i < l; i++) {
  markStaticRoots(node.children[i], isInFor || !!node.for);
}
```

成为一个根静态节点的要求
1、是静态节点
2、必须有子节点
3、子节点不能只是一个文本，不然优化的成本会大于收益

```js
if (
  node.static &&
  node.children.length &&
  !(node.children.length === 1 && node.children[0].type === 3)
) {
  node.staticRoot = true;
  return;
} else {
  node.staticRoot = false;
}
```

同样的对子节点和带有 v-if 判断条件的 block 内容节点进行 markStaticRoots 递归操作

```js
if (node.children) {
  for (let i = 0, l = node.children.length; i < l; i++) {
    markStaticRoots(node.children[i], isInFor || !!node.for);
  }
}
if (node.ifConditions) {
  for (let i = 1, l = node.ifConditions.length; i < l; i++) {
    markStaticRoots(node.ifConditions[i].block, isInFor);
  }
}
```

## 生成代码

根据 AST 节点生成 render 代码

```js
const code = generate(ast, options);
```

```js
export function generate(
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  // 根据配置生成基本的state对象
  const state = new CodegenState(options);
  const code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns,
  };
}
```

先根据配置生成基本的 state 对象，就是一个初始化各种属性值，生成一个包含各种信息的对象，然后判断是否存在 ast 节点，存在的话就调用 genElement，不存在就生成创建一个空 div 元素的 render 函数

```js
const state = new CodegenState(options);
const code = ast ? genElement(ast, state) : '_c("div")';
```

### genElement

根据不同的元素属性类型，进行不同的处理，一旦对对应的处理过了，就会设置对应的 Processed 属性为 true，表示已被相关的处理。

由于 AST（抽象语法树）本身就是一颗对象树，而且 vue 也规定必须唯一一个元素包裹，所以就可以从第一个节点进入，然后递归整棵 AST 树，就可以生成整个 render 函数

```js
export function genElement(el: ASTElement, state: CodegenState): string {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }
  // 执行未被处理过的静态根节点
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
    // 执行未被处理过的有v-once的节点，只渲染一次的节点
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
    // 执行未被处理过的带有for属性的节点
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
    // 执行未被处理过的带有if属性的节点
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
    // 执行未被处理过的不带slot属性的template标签
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
    // 处理slot标签元素
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    let code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      let data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData(el, state);
      }
      // 如果该元素没有inline-template内联模板的属性，将对其子元素同样执行
      const children = el.inlineTemplate ? null : genChildren(el, state, true);

      // 递归，以此将子节点由父节点包裹
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`;
    }
    // module transforms
    for (let i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code;
  }
}
```

:::tip

```js
<p class="text">12345</p></div>
"_c('p',{staticClass:"text"},[_v("12345")])"

<div><ele-button></ele-button><p class="text">12345</p></div>
"_c('div',[_c('ele-button'),_c('p',{staticClass:"text"},[_v("12345")])],1)"
```

\_字母的都是 render 相关的方法简写，具体参考 Virtual DOM 篇章

```js
vm._c = function(a, b, c, d) {
  return createElement(vm, a, b, c, d, false);
};

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  // ...
}
```

:::

### genStatic

处理静态节点

```js
// hoist static sub-trees out
function genStatic(el: ASTElement, state: CodegenState): string {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  const originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`);
  state.pre = originalPreState;
  return `_m(${state.staticRenderFns.length - 1}${
    el.staticInFor ? ',true' : ''
  })`;
}
```

这里我们就可以知道 staticRenderFns 是做了什么，会将一些静态节点生成的 render 函数加入到 staticRenderFns，然后将当前静态节点在 staticRenderFns 的索引位置由\_m(索引)包裹，那么当 render 函数执行的时候，遇到\_m 就会根据索引值去 staticRenderFns 中寻找，其实就是哟中缓存机制

```js
state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`);

return `_m(${state.staticRenderFns.length - 1}${
  el.staticInFor ? ',true' : ''
})`;
```

### genChildren

对子节点进行递归操作

```js
export function genChildren (
  el: ASTElement,
  state: CodegenState,
  checkSkip?: boolean,
  altGenElement?: Function,
  altGenNode?: Function
): string | void {
  // 对每个子节点进行处理
    const gen = altGenNode || genNode
    return `[${children.map(c => gen(c, state)).join(',')}]${
      normalizationType ? `,${normalizationType}` : ''
    }`
  }
}
```

### genNode

对 3 种节点的处理：元素，注释，文本

```js
function genNode(node: ASTNode, state: CodegenState): string {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}
```

处理文本节点，判断是否带有动态变量的话

- 有：就取 expression，因为 expression 本身就是将动态数据+纯文本包装好的 render 函数 -没有：就是纯文本，就取字符串，使用\_v 包裹

```js
export function genText(text: ASTText | ASTExpression): string {
  // 如果带有动态变量的话，就取expression，如果是纯文本，就取字符串，使用_v包裹
  return `_v(${
    text.type === 2
      ? text.expression
      : transformSpecialNewlines(JSON.stringify(text.text))
  })`;
}
```

注释节点用\_e 包裹，直接取注释节点的文本内容部分

```js
export function genComment(comment: ASTText): string {
  return `_e(${JSON.stringify(comment.text)})`;
}
```

### genData

拼接元素所有的属性字符串

```js
export function genData(el: ASTElement, state: CodegenState): string {
  let data = '{';
  const dirs = genDirectives(el, state);
  if (dirs) data += dirs + ',';

  // key
  if (el.key) {
    data += `key:${el.key},`;
  }
  // ref
  if (el.ref) {
    data += `ref:${el.ref},`;
  }
  if (el.refInFor) {
    data += `refInFor:true,`;
  }
  // ...
  return data;
}
```

## vue-loader

其实在调试的时候，我们会发现一个问题，就是在子组件$mount的时候，$options.render 都是已经有处理好的 render 函数了，那么这个是什么时候已经生成的呢。

首先我们找到初始化传入的 options，发现 components 属性其实已经被处理好了，值已经是一个被包装好的对象，其内容就是子组件相关的信息

![init_options](/源码/vue源码/模板编译/init_options.png)

而且我们还能找到 render 函数，也是已经被处理好的了

![init_options_fn](/源码/vue源码/模板编译/init_options_render_fn.png)

点击[[FunctionLocation]]边上的地址就可以看到方法详情

![init_options_fn](/源码/vue源码/模板编译/init_options_render_fn_1.png)

这个时候，就有一个想法涌上心头，是不是 import 导入的时候就已经处理好了！！！而处理模块化，完全是交付给了 webpack 下配置的 vue-loader，所以我们就去 vue-loader 中寻找答案

该方法就是当遇到.vue 文件的时候处理的 loader 逻辑

```js
// vue-loader/lib/loaders/templateLoader.js
module.exports = function(source) {
  // ...
  const compiled = compileTemplate(finalOptions);
  // ...
  const { code } = compiled;
  // finish with ESM exports
  return code + `\nexport { render, staticRenderFns }`;
};
```

输出的例子

```js
var render = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c('div', { attrs: { ok: '' } }, [
    _c('h1', { class: _vm.$style.red }, [_vm._v('hello')]),
  ]);
};
var staticRenderFns = [];
render._withStripped = true;

export { render, staticRenderFns };
```

由此，我们可以知道 vue-loader 已经将 template 中 import 导入的组件转化处理成了 render 函数，因此我们可以直接从$options中获取（具体可以查看Virtual DOM篇章，子组件Ctor是如何继承，然后将属性都赋值到$options 的）

所以说 vue 自带的模板编译只处理 main.js 下的模板，当然你也可以使用 Vue.components 等 API 创建组件，然后都写在一起，那么 vue 自带的编译模板才能起到它的作用，而一般开发的时候我们都使用模块化，子组件很多的模板编译部分其实都是 vue-loader 等提前处理好的，所以选择 vue 运行版优势就更大了，因为本身就是要利用 vue-loader 的，何不减小 vue 文件的体积！！！

## 总结

<a data-fancybox title="模板编译流程" href="/源码/vue源码/模板编译/模板编译流程.svg">![模板编译流程](/源码/vue源码/模板编译/模板编译流程.svg)</a>
