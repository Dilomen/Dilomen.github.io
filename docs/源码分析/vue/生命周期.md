## 概述

生命周期就是指一个事物的开始至结束的整一个过程，回归到 vue 那么就是从初始化到编译，挂载，销毁的整个过程，看过官方的生命周期大图又或是看到别人的博客总结，我们都能大致的了解到 vue 的整一个过程。

- 初始化阶段：初始化属性，方法，响应式数据等
- 模板编译阶段：将模板编译成渲染函数
- 挂载阶段：将实例挂载到指定的 DOM 上，渲染成真实 DOM
- 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器

## 执行内容

```js
// src/core/instance/index.js
function Vue(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  // 开始实例化Vue
  this._init(options);
}
// 初始化生命周期，初始化数据，挂载操作等
initMixin(Vue);
// 以下是在 Vue 的原型链上注册全局方法，这边只是简单的列一下，具体查看全局方法篇章
// 数据相关的全局方法: $data,$props,$set,$delete,$watch
stateMixin(Vue);
// 事件处理相关的全局方法: $on,$once,$off,$emit
eventsMixin(Vue);
// 生命周期相关的全局方法: _update,$forceUpdate,$destroy
lifecycleMixin(Vue);
// render相关的全局方法: $nextTick,_render
renderMixin(Vue);

export default Vue;
```

## initMixin

```js
export function initMixin(Vue: Class<Component>) {
  // 在Vue原型链上注册_init方法，这下我们就知道实例化this._init执行的是什么了
  Vue.prototype._init = function(options?: Object) {
    const vm: Component = this;
    // 每一个组件都会进行uid的递增
    vm._uid = uid++;
    // merge options
    if (options && options._isComponent) {
      // 对内部组件进行优化特殊处理，主要就是将父组件上的属性和绑定方法传递给子组件的options
      initInternalComponent(vm, options);
    } else {
      // 合并用户配置和原有的默认配置
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');
    // 挂载元素
    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}
```

### initLifecycle

主要是对当前组件进行一些初始化的属性设置

```js
export function initLifecycle(vm: Component) {
  const options = vm.$options;

  // locate first non-abstract parent
  let parent = options.parent;
  // 找到不是抽象组件的父组件，即不带有abstract属性，抽象组件一般如keep-alive等，不作为真实的DOM存在
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }
  // 设置组件的父组件
  vm.$parent = parent;
  // 设置组件的祖先组件，由于和父组件一个是同一个祖先，所以当存在父组件时，直接取父组件上的祖先属性
  vm.$root = parent ? parent.$root : vm;
  // 初始化一些属性
  // ...
}
```

### initEvents

绑定父级的一些事件，如<组件名 @change="handleChange" />

```js
export function initEvents(vm: Component) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  const listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}
```

```js
<todo-list @change="handleChange" @parentFn="handleEvent"></todo-list>
```

<a data-fancybox title="初始化父级事件" href="/源码/vue源码/生命周期/初始化父级事件.png">![初始化父级事件](/源码/vue源码/生命周期/初始化父级事件.png)</a>

updateComponentListeners 主要是将 add,remove 绑定事件和移除事件的方法传递给 updateListeners 方法

```js
export function updateComponentListeners(
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
) {
  target = vm;
  updateListeners(
    listeners,
    oldListeners || {},
    add,
    remove,
    createOnceHandler,
    vm
  );
  target = undefined;
}

function add(event, fn) {
  target.$on(event, fn);
}

function remove(event, fn) {
  target.$off(event, fn);
}
```

updateListeners 方法主要是绑定的老方法和绑定的新方法的比对，如果老的不存在，就绑定，如果老的存在，新的不存在就移除

```js
export function updateListeners (
  on: Object, // 新的方法
  oldOn: Object, // 老的方法
  add: Function,
  remove: Function,
  createOnceHandler: Function,
  vm: Component
) {
  let name, def, cur, old, event
  for (name in on) {
    def = cur = on[name]
    old = oldOn[name]
    // ...
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        // 处理绑定的方法，如果有多个方法就执行多个，如果只有一个就执行一个
        cur = on[name] = createFnInvoker(cur, vm)
      }
      // 如果老的不存在，就新绑定事件
      add(event.name, cur, event.capture, event.passive, event.params)
      // 如果都有，但是引用不一样，就改变老的绑定回调函数，然后在将新的方法引用替换
    } else if (cur !== old) {
      old.fns = cur
      on[name] = old
    }
  }
  // 如果老的有，新的没有，就移除
  for (name in oldOn) {
    if (isUndef(on[name])) {
      // normalizeEvent是对事件的一些修饰符进行处理，如事件前带有&就是passive
      // 返回一个对象
      // {
      //   name, // 绑定名： @click就是click
      //   once, // 是否值响应一次
      //   capture, // 是否开始捕获机制
      //   passive // 不执行e.preventDefault()
      // }
      event = normalizeEvent(name)
      remove(event.name, oldOn[name], event.capture)
    }
  }
}
```

<todo-list @&click="handleChange" @change="handleChange" @parentFn="handleEvent"></todo-list>

<a data-fancybox title="事件修饰符" href="/源码/vue源码/生命周期/事件修饰符.png">![事件修饰符](/源码/vue源码/生命周期/事件修饰符.png)</a>

### initRender

这里主要是对 slot 内容进行对应属性的处理，和将 createElement 方法绑定到实例上，以便后边使用，以及对$attr和$listener 进行对象监听处理，用以处理 HOC 函数

```js
export function initRender(vm: Component) {
  // 处理slot内容
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false);
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true);
  // 对$attr和$listener进行对象监听处理
  {
    defineReactive(vm, '$attrs', ...);
    defineReactive(vm, '$listeners', ...);
  }
}
```

### beforeCreate

可以看到我们熟悉的 beforeCreate 生命钩子被调用了

```js
callHook(vm, 'beforeCreate');
```

```js
export function callHook(vm: Component, hook: string) {
  // 加入栈，以便管理层级关系（如父子组件）
  pushTarget();
  const handlers = vm.$options[hook];
  const info = `${hook} hook`;
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    // 处理组件上绑定的hookEvent事件，如 <组件名 @hook:created="handle" />
    vm.$emit('hook:' + hook);
  }
  popTarget();
}
```

### initInjections 和 initProvide

这两个是分别是对 inject 注入和 provide 提供两个 API 进行初始化的，同时，从代码也可以看到，注入 inject 会在 data/props 初始化前，而 provide 在后。所以在 data 中是可以拿到 inject 的值的

```js
initInjections(vm); // resolve injections before data/props
initState(vm);
initProvide(vm); // resolve provide after data/props
```

### initState

由代码可知，先是初始化 props 的数据，再是 methods 方法，然后根据是否有 data 属性来生成 data 数据或者默认的空对象，接着再是初始化 computed，最后是 watch

```js
export function initState(vm: Component) {
  vm._watchers = [];
  const opts = vm.$options;
  if (opts.props) initProps(vm, opts.props);
  if (opts.methods) initMethods(vm, opts.methods);
  if (opts.data) {
    initData(vm);
  } else {
    observe((vm._data = {}), true /* asRootData */);
  }
  if (opts.computed) initComputed(vm, opts.computed);
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
```

#### 首先看下\$options 都有啥

<a data-fancybox title="实例属性" href="/源码/vue源码/生命周期/实例属性.png"><img width="500px" src="/源码/vue源码/生命周期/实例属性.png" /></a>

### initProps

```js
function initProps(vm: Component, propsOptions: Object) {
  // 父组件传下来的值（或者默认值）
  const propsData = vm.$options.propsData || {};
  const props = (vm._props = {});
  const keys = (vm.$options._propKeys = []);
  const isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  for (const key in propsOptions) {
    keys.push(key);
    // 对props的写法进行校验，对象？数组的形式，是否字符串，是否规范等等，并返回值
    const value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      // 对key字符名进行校验，如果是保留字或者不合法字符进行警告
      const hyphenatedKey = hyphenate(key);
      if (
        isReservedAttribute(hyphenatedKey) ||
        config.isReservedAttr(hyphenatedKey)
      ) {
        // warn(....)
      }
      // 对props被子组件修改进行警告
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          // warn(...);
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // 将props的属性代理到vm的属性，这样就可以直接通过vm访问到props的值
    if (!(key in vm)) {
      proxy(vm, `_props`, key);
    }
  }
  toggleObserving(true);
}
```

#### validateProp

该方式处理了如何拿到 props 中属性具体的值

```js
export function validateProp(
  key: string, // 当前
  propOptions: Object, // 配置的props对象
  propsData: Object, // 具体的带数据props对象
  vm?: Component // vm实例
): any {
  const prop = propOptions[key];
  const absent = !hasOwn(propsData, key);
  // 直接props数据对象中取值，不存在即为undefined
  let value = propsData[key];
  // 是否设置type为Boolean类型
  const booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    // 如果父组件没有传下来具体的数据，且配置里也不存在默认值，那么就返回false
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
      // 如果传下来的value值为空字符串或者属性值和属性名相同，如<组件 name="name" />， <组件 userName="user-name" />
    } else if (value === '' || value === hyphenate(key)) {
      const stringIndex = getTypeIndex(String, prop.type);
      // 如果type同时配置Boolean和String两种类型，那么Boolean类型优先级更高，即优先转成Boolean值
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // 如果父组件没有传下来值，那么就取默认值
  if (value === undefined) {
    // 取默认值就是default，如果是函数就执行返回结果，如果不是就直接返回值
    value = getPropDefaultValue(vm, prop, key);
    // 对默认值进行响应式处理
    const prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    !(__WEEX__ && isObject(value) && '@binding' in value)
  ) {
    // 对传下来的props值进行根据type类型或validator方法进行校验
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
```

### initMethods

初始化方法，只是将 methods 注册的方法进行校验，如值是否是 Function 类型，或者方法名是否和保留字冲突，以及和 props 的 key 命名是否冲突

```js
function initMethods(vm: Component, methods: Object) {
  const props = vm.$options.props;
  for (const key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      // 是否是Function类型
      if (typeof methods[key] !== 'function') {
        warn(...);
      }
      // 和props的key命名是否冲突
      if (props && hasOwn(props, key)) {
        warn(...);
      }
      // 是否和保留字冲突
      if (key in vm && isReserved(key)) {
        warn(...);
      }
    }
    // 在vm实例上直接绑定该方法
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}
```

### initData

初始化 data 也是将 data 的内容进行是否和 methods，props 命名冲突的校验和是否是保留字的校验，如果合法的话就赋值到 vm 实例的\_data 上

<a data-fancybox title="实例属性" href="/源码/vue源码/生命周期/实例属性.png"><img width="300px" src="/源码/vue源码/生命周期/vm_data.png" /></a>

```js
function initData(vm: Component) {
  let data = vm.$options.data;
  // 获取data的内容，如果是函数就是call绑定到当前vm实例执行函数，拿到返回的对象，如果是对象就直接返回
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  // 如果data不是一个对象，就警告
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' &&
      warn(...);
  }
  const keys = Object.keys(data);
  const props = vm.$options.props;
  const methods = vm.$options.methods;
  let i = keys.length;
  while (i--) {
    const key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      // 是否与methods方法名冲突
      if (methods && hasOwn(methods, key)) {
        warn(...);
      }
    }
    // 是否与props属性冲突
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' &&
        warn(...);
    // 是否是保留字，不是话的就绑定到vm实例的_data上
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key);
    }
  }
  // 对data数据进行响应式处理
  observe(data, true /* asRootData */);
}
```

:::tip 校验
校验只会在开发环境做出警告，但是并不影响整个编译，即还是会执行你的页面，但是就会埋下各种风险，所以还是要很重视这些警告！毕竟其违法了 vue 的规则
:::

### initComputed

```js
function initComputed(vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = (vm._computedWatchers = Object.create(null));
  // computed properties are just getters during SSR
  const isSSR = isServerRendering();

  for (const key in computed) {
    const userDef = computed[key];
    // computed有两种写法，根据判断是否是funtion类型来获取getter方法
    // 1、
    // title() {
    //   return 'Hello'
    // }
    // 2、
    // title: {
    //   get() {
    //     return 'Hello'
    //   }
    //   set () {}
    // }
    const getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(`Getter is missing for computed property "${key}".`, vm);
    }

    if (!isSSR) {
      // 每一个computed属性创建一个Watcher实例
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // 是否与vm实例上的属性冲突，没有就定义Computed，有就警告
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(...);
    }
  }
}
```

#### defineComputed

```js
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop,
};

export function defineComputed(
  target: any,
  key: string,
  userDef: Object | Function
) {
  // 是否是服务端渲染，服务端渲染的话就不需要做缓存
  const shouldCache = !isServerRendering();
  // 根据computed的写法来赋值getter方法和setter方法
  if (typeof userDef === 'function') {
    // 如果是缓存那么就直接触发createComputedGetter方法获取值，没有缓存就通过createGetterInvoker方法来执行userDef方法获取值
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  // 如果是没有设置setter的，那么当直接改变computed对应的属性时，就会警告
  if (
    process.env.NODE_ENV !== 'production' &&
    sharedPropertyDefinition.set === noop
  ) {
    sharedPropertyDefinition.set = function() {
      warn(...);
    };
  }
  // 然后监听对vm实例上
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
```

#### createComputedGetter

```js
function createComputedGetter(key) {
  return function computedGetter() {
    // 拿到对应key下的watcher实例，之前有为每个属性生成Watcher实例
    // const computedWatcherOptions = { lazy: true }
    // watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    const watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      // dirty变成true就表示依赖的数据发生了变化，触发了watcher的updated方法
      if (watcher.dirty) {
        watcher.evaluate();
      }
      // 收集数据依赖，一旦依赖的数据发生变化，那么就会触发update方法
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}
```

Watcher 关于 computed 的处理（注：以下的描述都是单指 computed 的）
首先在生成 Watcher 实例的时候，带了{ lazy: true }作为配置项

```js
export default class Watcher {
  constructor(
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    if (options) {
      //...
      this.lazy = !!options.lazy;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    // 所以在computed中默认为true
    this.dirty = this.lazy;
    // 绑定getter方法
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
      }
    }
    // 默认值也为undefined
    this.value = this.lazy ? undefined : this.get();
  }

  get() {
    let value;
    const vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    }
    return value;
  }

  // 当数据发生变化时，dirty才会变成true，才能调用evaluate，所以dirty值就是来判断是否发生变化的
  update() {
    if (this.lazy) {
      this.dirty = true;
    }
    // ...
  }

  // 当依赖的数据发生变化时
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
  // 收集依赖
  depend() {
    let i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  }
}
```

### initWatch

```js
function initWatch(vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key];
    // watch可以支持数组，字符串（方法名），函数，对象类型，这边主要已多个和单个区分，对每一个绑定的方法都执行createWatcher方法
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}
```

```js
function createWatcher(
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // 如果是对象的话，就是{handler: function() {}}的写法，所以获取handler
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  //   Vue.prototype.$watch = function (expOrFn, cb, options) {
  //   var watcher = new Watcher(vm, expOrFn, cb, options);
  // }
  // 同样也是利用Watcher实例，通过回调函数，当数据发生变化时，触发回调函数
  return vm.$watch(expOrFn, handler, options);
}
```

## created

终于搞定了各种数据的初始化，然后又返回到了生命周期钩子

说明这个时候 created 已经可以访问到所有初始化的数据了

```js
callHook(vm, 'created');
```

如果在 vue 配置中设置了性能监控，这边也会出现相应的处理

```js
if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
  vm._name = formatComponentName(vm, false);
  mark(endTag);
  measure(`vue ${vm._name} init`, startTag, endTag);
}
```

## mount

接着就是开始挂载工作

```js
// 如果挂载元素存在
if (vm.$options.el) {
  vm.$mount(vm.$options.el);
}
```

### 挂载处理

之前在运行机制中讲到，vue 分两个版本，一个是完整版，一个是运行版，两者主要是是否带有 compiler 编译的功能，因为挂载元素和这个编译已经是相关了，所以两者也采取的是不用的处理方式

- 运行版

```js
// vue/src/platforms/web/runtime/index.js
Vue.prototype.$mount = function(
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};
```

- 完整版

```js
// 先缓存运行版本的$mount方法
const mount = Vue.prototype.$mount;
Vue.prototype.$mount = function(
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el);

  // 如果挂载节点是HTML根节点，那么就警告
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &&
      warn(...);
    return this;
  }

  const options = this.$options;
  // 以下就会根据选项中是否有来判断处理，render优先级最高，然后是template和，其次是el
  // new Vue({
  //   el: '#app',
  //   template: '<App />',
  //   render: (h) => {}
  // })
  // 是否有render渲染函数，如果有直接进行挂载操作，如果没有就先进行将模板转成render渲染函数
  if (!options.render) {
    let template = options.template;
    if (template) {
      /**
       * template的三种写法
       * 1、template: `<h1>Hello</h1>`
       * 2、<html><div id="app"><template id="content"></template></div></html>
       *   template: '#content'
       * 3、<script type="x-template" id="content"></script>
       *   template: '#content'
       */
      if (typeof template === 'string') {
        // 如果模板是#开始，那就查找id为template值的元素
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            );
          }
        }
        // 如果template直接是节点，就取innerHTML内容
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    // 如果没有template，那么就获取包含元素的HTML内容
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile');
      }
      // 然后就是使用模板编译将模板转化成render函数,详情请看模板编译篇章
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: process.env.NODE_ENV !== 'production',
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments,
        },
        this
      );
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(`vue ${this._name} compile`, 'compile', 'compile end');
      }
    }
  }
  // 最后同样的调用运行版本的$mount
  return mount.call(this, el, hydrating);
};
```

由上述代码对比可知，完整版确实只多了模板编译的部分，然后两者都会调用 mountComponent 方法

### mountComponent

```js
export function mountComponent(
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el;
  // 如果没有render函数就创建一个空节点，如果是运行版，就警告运行版没有模板编译，如果不是就警告没有找到render函数
  if (!vm.$options.render) {
    // ...
  }
  // 开始进入beforeMount生命钩子
  callHook(vm, 'beforeMount');

  //...
  updateComponent = () => {
    // _render是得到VNode树，_update是diff新旧VNode来进行更新操作
    vm._update(vm._render(), hydrating);
  };

  // 创建Watcher实例，updateComponent作为第二个参数就是getter的作用，会收集模板中所有的数据依赖，一旦发生变化，就会触发updateComponent函数
  new Watcher(
    vm,
    updateComponent,
    noop,
    {
      before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      },
    },
    true /* isRenderWatcher */
  );
  hydrating = false;
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}
```

## render

首先我们由上述代码可以看到 vm.\_render()，是的这就是 render 的过程，由此我们也可以知道 render 是在 beforeMount 和 Mounted 之间的，也是 beforeUpdate 和 updated 之间的

```js
export function renderMixin(Vue: Class<Component>) {
  // ...
  Vue.prototype._render = function(): VNode {
    const vm: Component = this;
    const { render, _parentVnode } = vm.$options;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    let vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      // 执行render函数，然后生成VNode，就是"with(this){return _c('button',[_v("Hello World")])}"
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      // 将错误栈stack渲染到页面，也就是我们经常遇到的错误页面
      handleError(e, vm, `render`);
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(
            vm._renderProxy,
            vm.$createElement,
            e
          );
        } catch (e) {
          handleError(e, vm, `renderError`);
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // 如果是一个数组，但只有一个就取第一个
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      // 不应该有多个根节点，需要有一个根节点包裹，也是平时常见的警告问题
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
            'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}
```

## beforeUpdate 和 updated

这个生命周期钩子并不是直接执行的，它是由 props 或者 data 发生变化的时候，才触发的，而 data 和 props 的监听完全由 Watcher 实例来监听，所以我们找到了 Watcher 的 update 的方法

```js
class Watcher {
  // ...
  update() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  }
  //...
}
```

```js
export function queueWatcher(watcher: Watcher) {
  const id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue();
        return;
      }
      nextTick(flushSchedulerQueue);
    }
  }
}
```

```js
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  let watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  // 将刷新的watch进行排序，保证先父组件，再子组件
  queue.sort((a, b) => a.id - b.id);

  // 对每一个Watcher实例进行
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    // 执行绑定的before方法，这边就是执行beforeUpdate生命周期
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // 在开发模式打包中，更新的内容超过100个的时候，就进行警告
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' +
            (watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`),
          watcher.vm
        );
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice();
  const updatedQueue = queue.slice();

  resetSchedulerState();

  // 执行activated生命周期
  callActivatedHooks(activatedQueue);
  // 执行updated生命周期
  callUpdatedHooks(updatedQueue);

  // 如果安装了vue-devtools，就触发flush事件
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}
```

```js
function callUpdatedHooks(queue) {
  let i = queue.length;
  while (i--) {
    const watcher = queue[i];
    const vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
```

由上述可知，当数据变化的时候会触发会调用 getter 方法，也就是 updateComponent，从而调用实例的\_update 方法，进行 VNode 的比对，进行渲染更新，由于该篇只涉及生命周期，所以不再展开，具体请看 Virtual DOM 篇章

```js
Vue.prototype._update = function(vnode: VNode, hydrating?: boolean) {
  // ...
  if (!prevVnode) {
    // 初次渲染
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
  } else {
    // 更新渲染
    vm.$el = vm.__patch__(prevVnode, vnode);
  }
  // ...
};
```

## beforeDestroy 和 destroyed

这两个生命周期钩子是由 vm 实例调用\$destroy 方法执行的，具体执行位置是在新旧 VNode Tree 比较后，旧 VNode 中被去掉的组件就会调用\$destroy 方法，具体可以看 Virtual DOM 篇章

```js
Vue.prototype.$destroy = function () {
    const vm: Component = this
    // 首先如果已经是在销毁过程中了，那么直接退出
    if (vm._isBeingDestroyed) {
      return
    }
    // 执行beforeDestroy生命周期钩子
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // 如果是存在父级，那么从父级清除子级
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // 将依赖自身的观察者清空
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    // 将自身依赖的观察者清空，如实例中的data数据等等
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // 执行destroyed
    callHook(vm, 'destroyed')
    // 对实例所有的事件listener清空
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
```

## 总结

<a data-fancybox title="vue生命周期流程图" href="/源码/vue源码/生命周期/vue生命周期流程图.svg">![vue生命周期流程图](/源码/vue源码/生命周期/vue生命周期流程图.svg)</a>
