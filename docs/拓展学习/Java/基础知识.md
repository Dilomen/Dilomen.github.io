---
title: 基础知识
tags: java基础知识
categories: java基础知识
keywords: java,基础
description: java的基础知识
abbrlink: 606938d0
date: 2019-06-11 12:57:37
---

## **java 是使用引用去操纵对象的**

```java
String s;
```

这里创建的只是引用，而不是对象

---

## **存储位置**

- 寄存器： 最快的存储区，但是寄存器有限，且不能直接控制（C/C++可以）
- 堆栈： 在通用 RAM（随机访问存储器）中，需要通过堆栈指针来控制存储，向下移动就是分配新的内存，向上移动，就是释放对应内存
- 堆： 通用的内存池（也位于 RAM 区），用于**存放所有的 Java 对象**，灵活性更高，但是性能没有堆栈好
- 常量存储： 常量通常存放在代码中，在嵌入式开发中，可以选择放在 ROM（只读存储器）中
- 非 RAM 存储：存放一些**持久化信息**，如流对象和持久化对象

---

## **通过 null 来判断是否指定对象:**

Java 创建一个数组对象时，实质就是创建一个引用数组，每个引用都会自动初始化为一个特定值，该值拥有自己的关键字 null，Java 可以通过这个 null 来判断引用是否已指定一个对象

## **作用域**

- Java 和 C，C++一样是具有作用域的，作用域决定了其内定义的变量名的可见性和生命周期，一般以{}的位置来决定
- Java 的对象不和基本类型一样的生命周期，它们可以存活在作用域外面，它们的清理工作由 Java 的垃圾回收器检测并将不会再被引用的对象进行回收处理

```java
{
    String s = new String("a");
}
```

引用 s 在作用域结束的时候就消失了，但是 s 指向的对象仍然占据内存空间

## **static 使类不需要创建对象就可以调用**

```java
class Test {
    static int i = 1;
}
// Test.i就可以访问，不需要通过new创建对象再使用
```

- 静态方法不能访问 this 变量
- 静态方法不能访问实例字段
- 静态方法可以访问静态字段

**tip:** system.out.println 就是使用了 static 的方式，out 是一个静态的 PrintStream 对象，因为是静态的，所以可以直接使用

还有 Arrays.sort()和 Math.random()等工具类也是使用了静态方法

静态方法经常用于辅助方法

## Java 程序的入口 main()也是静态方法

## static 声明赋值

**static 声明的赋值为对象的变量会直接执行类的对应构造方法**

```java
public class B {
    public static B b = new B();
    public B(){
        System.out.println("a");
    }
    public static void main(String[] args) {
    }
}
```

---

## **编码风格**

类名的首字母必须大写，类名如果是由几个单词组成，就连在一起，不要使用下划线
方法，字段（成员变量）和对象引用名称使用小驼峰形式

---

## **特殊值**

```java
double d1 = 0.0 / 0;     //NaN， 不是一个数字类型
double d2 = 1.0 / 0;     //Infinity表示无穷大
double d3 = -1.0 / 0;    //-Infinity表示无穷大
```

---

## **数组注意项**

- 数组类型是 类型[]
- 数组初始化用 int[] array = new int[5];
  也可以 int[] array = {4,5,6,7,8};
- 数组创建后的大小不可改变

---

## **数组依赖包**

Arrays.sort() 排序
Arrays.toString() 将整个数组显示出来

```java
import java.util.Arrays;
public class Double_demo {
    public static void main(String args[]) {
        int[] array = {9, 7, 3, 4};
        Arrays.sort(array);
        System.out.println(Arrays.toString(array));
    }
}
```

---

## **protected 的使用**

子类可以访问到父类 protected 定义的参数或方法

```java
public class City {
    protected String name;
}
public class Beijing extends City {
    public void hello() {
        System.out.println(this.name);
    }
}
```

---

## **@Override**

- 子类覆写父类的方法是覆盖（Override）
- 加上@Override 可以让编译器帮助检查是否进行了正确的覆写
- @Override 不是必需的

```java
public class City {
    private String name;
    public String getName() {
        return name;
    }
}
public class Beijing extends City {
    @Override
    public String getName() {
        return "hello";
    }
}
```

---

## **super 可以调用父类被覆写的方法**

```java
public class Beijing extends City {
    @Override
    public String getName() {
        return super.getName();
    }
}
```

子类构造方法可以通过 super 继承父类的构造方法

```java
public class Test {
    public Test (Integer i){
        System.out.println("Test: " + i);
    }
}
public class TestChild extends Test {
    public TestChild() {
        super(10);
        System.out.println("TestChild: " + 2);
    }
}
TestChild testChild = new TestChild();
输出
Test: 10
TestChild: 2
```

---

## **final**

- final 修饰的方法不能被 Override
- final 修饰的类不能被继承
- final 修饰的字段初始化后不能被修改
- final 定义的对象必须在使用前进行赋值

---

## **抽象方法 abstract**

- 如果一个 class 定义类方法，但没有具体执行代码，这个方法就是抽象方法
- 抽象方法用 abstract 修饰
- 抽象方法没有任何执行语句
- 因为无法执行抽象方法，所以这个类也必须申明为抽象类（abstract class）
- 无法实例化一个抽象类 new 抽象类 ❌

```java
public abstract class AbstractFather {
    public abstract void getName();
}
```

**抽象类的作用：**

- 抽象类用于被继承
- 抽象类可以强制让子类实现其定义的抽象方法

---

## **接口 Interface**

如果一个抽象类没有字段，所有方法全部是抽象方法，就可以把该抽象类改写为接口

- 接口中的作用域都是隐式声明 final 和 static

```java
public interface CanFly {
    int i = 0;
    Test test = new Test();
    void fly();
}
// 就可以直接使用作用域声明的变量
// CanFly.i;
// CanFly.test;
```

- 使用 interface 声明一个接口
- 接口定义的方法默认是 public abstract（不需要写）

```java
public interface InterfaceA {
    void run();
}
```

- 一个 interface 可以继承另一个 interface
- interface 继承自 interface 使用 extends
- 相当于拓展类接口的方法

---

## **使用 package 避免类名冲突**

Java 定义了名字空间：包
包名 + 类名 = 完整类名(导入)

---

## **把任意数据转化为 String**

```java
String.valueOf(123); // "123"
String.valueOf(true); // "true"
```

---

## **StringBuilder 拼接字符串**

String 可以用+拼接
但是如果多次循环拼接都会创建新的字符串对象，造成了内存和效率浪费

StringBuilder 可以高效拼接字符串
StringBuilder 是可变对象
StringBuilder 可以预分配缓冲区

```java
StringBuilder stringBuilder = new StringBuilder();
for (int i = 0; i < 10; i++) {
    stringBuilder.append(String.valueOf(i));
}
System.out.println(stringBuilder); // 0123456789
```

StringBuilder 可以进行链式操作
stringBuilder.append('a').append('b').append('c').append('d');

当使用+多个连接，系统会默认转化为 StringBuilder

---

## **enum 枚举定义常量**

```java
public enum Color {
    RED, GREEN, BLUE;
}
也可以初始化
public enum Color {
    RED("红色"), GREEN("绿色"), BLUE("蓝色");
    private String chinese;
    private Color(String chinese) { // 该构造方法必须为private
        this.chinese = chinese;
    }
    public String toChinese () {
        return chinese;
    }
}
```

枚举有 ordinal 和 values 方法

- ordinal()方法是返回 enum 常量的索引

```java
Color.BULE.ordinal(); // 2
```

- values()方法是生成这些常量值构成的数组

```java
for (EnumOrder i:EnumOrder.values()) {
    System.out.println(i); // RED, BULE, GREEN
}
```

---

## **注解**

如：@Override

- 注解(Annotation)是放在 Java 源码的类、方法、字段、参数前的一种标签
- 注解本身对代码逻辑没有任何影响，如何使用注解由工具决定
- 注解可以定义配置参数和默认值

---

## **泛型**

- JDK 提供了 ArrayList，可以看作是“可变长度“的数组，可以有 add()等方法,
  但是如果需要声明存储的类型，如 String 类型，需要强制转换，而且容易出错
  ,为了方便声明存储的类型，就需要泛型 ArrayList\<T>
  - 泛型就是编写模版代码来适应任意类型
  - 不必对类型进行强制转换
  - 编译器将对类型进行检查

```java
ArrayList<String> list = new ArrayList();
list.add("aaa");
```

- **编写泛型**

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public void getString() {
        System.out.println(first + " " + last);
    }
}
// 调用
Pair<String> pair = new Pair("hello","world");
pair.getString();

```

- **泛型方法不能直接在静态字段或静态方法中使用\<T>，而是要使用其他的类型\<K>**，在方法返回值前面写明泛型

```java

public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    static <K> Pair<K> getString(K first, K last) {
        return new Pair<K>(first, last);
    }
}
Pair<String> pair = Pair.getString("hello","world");

```

---

## **Java 泛型的实现**

Java 的泛型是采用擦拭法实现
擦拭罚决定来泛型\<T>:

- 不能是基本类型，例如：int
- 不能获取带泛型类型的 Class，例如：Pair\<String>.class
- 不能判断带泛型类型的类型， 例如： x instanceof Pair\<String>
- 不能实例化 T 类型，例如：new T()
- 泛型方法要防止重复定义方法，例如：public boolean equals(T obj)
  子类可以获取父类的泛型类型\<T>

---

## **List**

List 是一种有序列表，通过索引访问元素。

- boolean add(E e) 在末尾添加一个元素
- boolean add(int index, E e) 在指定索引添加一个元素
- void addAll(Collection c) 在指定索引添加一个容器的所有元素
- int remove(int index) 删除指定索引的元素
- boolean contains(Object element) 是否包含该元素
- boolean containsAll(Collection c) 是否包含容器所有元素
- int remove(Object e) 删除某个元素
- E get(int index) 获取指定索引的元素
- int size() 获取链表大小(包含元素的个数)
- List 有 ArrayList 和 LinkedList 两种实现，优先使用 ArrayList。 遍历 List 使用 Iterator 或者 foreach 循环
- List 和 Array 可以相互转换。
  - List->Array:list.toArray()
  - Array->List:Arrays.asList(array)
    // 但是这个转化的 list 是只读的，没有原先的方法，如 add,需要创建一个新的 ArrayList 对象，然后赋值
  - List\<Integer> arrayList = new ArrayList<>(Arrays.asList(array));

## **Set**

Set\<E>用于存储不重复的元素集合

## **Map**

Map 是一种键值映射表，可以通过 Key 快速查找 Value，(键名不能重复,后者会覆盖前者)

- 常用方法:
  - put(K key, V value):把 Key-Value 放入 Map
  - get(K key):通过 Key 获取 Value
  - boolean containsKey(K key):判断 Key 是否存在
  - 遍历 Map: 用 for...each 循环:
    - 循环 Key:keySet()
    - 循环 Key 和 Value:entrySet() 常用的实现类:
  - HashMap:**无序** SortedMap:**有序**，保证按 Key 排序，实现类有 TreeMap

```java

for (String key : map.keySet()) {
System.out.println(key + " -> " + map.get(key));
}

```

- 作为 key 的对象必须正确覆写 equals 和 hashCode
- 一个类如果覆写了 equals，就必须覆写 hashCode
- hashCode 可以通过 Object.hashCode()辅助方法实现

## **HashMap 底层实现**

- HashMap 底层实现采用类哈希表
  - 数组：占用空间连续。寻址容易，查询速度快，但是增加和删除效率低
  - 链表：占用空间不连续。寻址困难，查询速度慢，但是，增加和删除效率高
  - 哈希表的本质就是结合数组和链表的优势

## **Queue（队列）**

- Queue\<E>实现一个先进先出（FIFO）的队列
- add/offer 将元素添加到队尾
- remove/poll 从队首获取元素并删除
- element/peek 从队首获取元素但不删除
- 避免把 null 添加到队列

## **Deque\<E>实现了一个双端队列**

- 既可以添加到队尾，也可以添加到队首
- 既可以从队首获取，又可以从队尾获取
- 添加元素到队尾:addLast(E e) / offerLast(E e)
- 取队首元素并删除:E removeFirst() / E pollFirst()
- 取队首元素但不删除:E getFirst() / E peekFirst()
- 通用实现主要有两个实现类 ArrayDeque 和 LinkedList

```java

Deque<String> queue = new ArrayDeque<>();
queue.addFirst("b");
queue.addFirst("a");
System.out.println(queue.removeLast());

```

---

## **Stack（栈）**

栈是一种后进先出的数据结构

push: 把元素压栈

pop: 把栈顶的元素“弹出“

- java.util.Stack 类 Java 官方已经不在建议使用了。现在官方推荐使用 java.util.Deque,只调用 Deque 的 push/pop/peek 方法

```java

Deque<Integer> stack = new ArrayDeque<Integer>();

```

---

## **堆和栈的区别**

- 栈内存存储的是局部变量而堆内存存储的是实体；
- 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
- 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收

---

## **IO 流**

- IO 流是一种流式的数据输入/输出模型
- 二进制数据以 byte 为最小单位在 InputStream/OutputStream 中单向流动
- 字符数据以 char 为最小单位在 Reader/Writer 中单向流动
- JDK 的 java.io 包提供流同步的 IO 功能
- Java 的 IO 流的接口和实现是分离的：
  - 字节流接口： InputStream/OutputStream
  - 字符流接口： Reader/Writer

---

## **File 对象**

- File 对象表示一个文件或者目录：
- 创建 File 对象本身不涉及 IO 操作
- 获取路径 getPath()
- 获取绝对路径 getAbsolutePath()
- 获取 getCanonicalPath()
- 可以获取目录的文件和子目录
- 通过 File 对象可以创建或删除文件和目录

---

## **InputStream/OutputStream**

```java

try {
    InputStream inputStream = new FileInputStream("src/1.txt");
    int n;
    while((n = inputStream.read()) != -1) {
        System.out.println(n);
    }
} catch (IOException e) {
    throw new Error(e);
}

try {
    OutputStream outputStream = new FileOutputStream("2.txt");
    byte[] b1 = "Hello ".getBytes("UTF-8");
    outputStream.write(b1);
} catch (IOException e) {
    throw new Error(e);
}

```

---

## **时间 Date**

```java

// 获取当前时间
Date now = new Date();
// 指定格式打印
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
System.out.println(sdf.format(now));

```

---

## **time**

```java

LocalDate d = LocalDate.now();
LocalTime t = LocalTime.now();
LocalDateTime dt = LocalDateTime.now();
LocalDate d2 = LocalDate.of(2019, 8, 23);
System.out.println(d2);

```

---

## **Java 正则表达式**

```java

// 匹配
String input = "1990";
boolean is19xx = input.matches("19\\d\\d");
System.out.println(is19xx);
// 分割
String tags = "java php python";
String[] arr = tags.split("\\s");
System.out.println(Arrays.toString(arr));
// 查找
String s = "hello world, my name is linda";
Pattern p = Pattern.compile("my");
Matcher m = p.matcher(s);
while (m.find()) {
String sub = s.substring(m.start(), m.end()); // 匹配项索引开始值和索引结束值
System.out.println(sub);
}
// 替换
String s = "hello world, my name is linda";
String m = s.replaceAll(" ", ",");

```

## **多线程**

进程和线程的关系：

1. 一个进程可以包含一个或多个线程（至少一个线程）
2. 线程是操作系统最小任务单位
3. 如何调度线程完全由操作系统决定

Java 语言内置多线程支持：

- 一个 Java 程序实际上是一个 JVM 进程
- JVM 用一个主线程来执行 main()方法
- 在 main()方法中又可以启用多个线程

## **Tread**

- Java 用 Tread 对象表示一个线程，通过调用 start()启动一个线程
- 一个线程对象只能调用一次 start()
- 线程的执行代码是 run()方法
- 线程调度由操作系统决定，程序本身无法决定
- Tread.sleep()可以把当前线程暂停一段时间
- Java 线程对象 Tread 的状态包括：New/Runnable/Block/Waiting/Timed Waiting/Terminated
- 通过对另一个线程对象调用 join()方法可以等待其执行结束，再执行后面的代码
- 可以指定等待时间，超过等待时间线程仍然没有结束就不再等待
- 对已经运行结束的线程调用 join()方法会立刻返回

```java

public class MyThread extends Thread {
    public void run() {
        System.out.println(2);
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new Error(e);
        }
    }
}

Thread t = new MyThread();
    t.start();
    try {
        t.join();
    } catch (InterruptedException e) {
        throw new Error(e);
    }
System.out.println("hello");

```

## **中断线程**

- 调用 interrupt 方法可以中断一个线程

```java

t.interrupt();

```

- 通过检测 isInterrupted()标志获取当前线程是否已中断

```java

while(!isInterrupted()) {
    System.out.println(2);
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        throw new Error(e);
    }
}

```

- 如果线程处于等待状态，该线程会捕获 InterruptedException
- isInterrupted()为 true 或者捕获来 InterruptedException 都应该立刻结束
- 通过标志位判断需要正确使用 volatile 关键字

```java

volatile boolean running = true;
public void run() {
    while(running) {
        System.out.println(2);
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new Error(e);
        }
    }
}

t.running = false;

```

- volatile 关键字解决了共享变量在线程间的可见性问题

## **守护线程**

- 守护线程是为其他线程服务的线程
- 所有非守护线程都在执行完毕后，虚拟机退出
- 守护线程不能持有资源（如打开文件）

## **死锁产生的条件**

- 多线程各自有不同的锁，并且相试图获取对方已持有的锁
- 如何避免死锁：多线程获取锁的顺序要一致

## **Java 中的 get 请求**

```java

URL url = new URL("http://www/example.com/");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
int code = conn.getResponseCode();
try (InputStream input = conn.getInputStream()) {
// 读取响应数据
}
conn.disconnect();

```

## **Java 中的 post 请求**

```java

URL url = new URL("http://www/example.com/");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("POST");
conn.setDoOutput(true);
byte[] postData = "loginName=test&password=123456".getBytes("UTF-8");
conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
conn.setRequestProperty("Content-Length", String.valueOf(postData.length));
try (OutputStream output = conn.getOutputStream()) {
    output.write(postData);
}
int code = conn.getResponseCode();
try (InputStream input = conn.getInputStream()){
// 读取响应数据
}
conn.disconnect();

```

## **JDBC**

- 导入 jdbc 的 jar 包

```java

String JDBC_URL = "jdbc:mysql://localhost:3306/test";
String JDBC_USER = "root";
String JDBC_PASSWORD = "root";
try {
    Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);
} catch (SQLException e) {
    e.printStackTrace();
}

```

- Statement 接口

  - 用于执行静态 sql 语句并返回它所生成结果的对象
  - 常用的 Statement 类
    - execute(): 运行语句，返回是否有结果集
    - executeQuery(): 运行 select 语句，返回 resultSet 结果集
    - executeUpdate(): 运行 insert/update/delete 操作，返回更新的行数

  ```java
  Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);
  Statement statement = conn.createStatement();
  String sql = "insert into user (name) values ('lll')";
  statement.execute(sql);
  ```

  - PreparedStatement 继承 Statement,可以防止 sql 注入

  ```java
  String sql = "select * from user"
  PreparedStatement pstm = conn.prepareStatement(sql);
  ResultSet rs = pstm.executeQuery();
  while (rs.next()) {
    System.out.println(rs.getString("name"));
  }
  String sql = "insert into user (name) values (?)";
  PreparedStatement ps = conn.prepareStatement(sql);
  ps.setString("lll")
  ps.execute();
  ```

- Batch 批处理

```java

conn.setAutoCommit(false); // 设为手动提交
stmt = conn.creatStatement();
for (int i =0; i < 2000; i++) {
stmt.addBatch("insert into user (date) values (now())")
}
conn.commit(); // 提交事务

```
