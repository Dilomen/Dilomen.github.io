## 前言

最近在看一本叫《重构 改善既有代码的设计》这本书，虽然很多是思想，但是都值得让程序员去思考重构这件事，这里也当算是做个笔记。  
在我们编写程序中，往往随着时间的推移，一个好的程序设计会变得臃肿或者不符合当下需求，又或是曾经为了赶进度，代码设计有问题，这时候我们都需要通过重构来改善我们的代码————以便后期的维护和开发。

> 重构的唯一目的是让我们开发更快，它有时候会是一种短期内的成本损耗，但它在长期看来必定是收益颇丰的工作。是否重构应该是从价值判断的取舍，在合适的时候去进行适当规模的重构，能避免带来一定的损失，当然前提是你的老板本身是支持员工改善代码这件事，否则这种又累又不讨好的活可不是谁都爱干的哦 🐶

:::tip
重构应该是由经济利益驱动，当然它不会立即从经济收益中体现，毕竟他是服务开发的，它的价值在于提升开发效益，从而加快开发进度，由此实现的间接收益
:::

所以在落实重构这件事情上，不同的技术部门应该考虑当下的现状，比如本身员工是否主动愿意去做重构这件事，有比如当下是否对重构代码有测试进行同步支持，如果有，那么是以一种什么形式开展，如果没有，那么风险点是由谁来承担，即要有赏罚分明的制度等等，再者还需要权衡利弊，判断重构对当下的收益是否可观，或者说是否值得去做（这个往往是一些大的重构，如修改技术方案，技术架构调整等）。

#### 那么在来来说说重构的好处

重构可以小到修改命名，大到整个模块（重构和重写是不一样的！）

- 更加规范的命名可以让我们更加直观的明白其的作用或者含义
- 代码解耦，函数分解能让我们更加快速的找到对应的地方，并处理问题
- 设计更合理的方案，能满足更好的需求变更
- 性能优化和代码书写优化，也是重构的范畴
- 有利于后期维护工作和新需求的功能添加，对后面加入的开发者也会比较友好
- ...

## 第一章.示例

该书第一章是以一个函数作为示例，一步一步的将其重构，从而带领读者认知重构的魅力。

从提炼函数、改变传参、抽离变量、分离文件、多态优化等一系列手法将原本一个臃肿的函数“四分五裂”地改成了一堆功能明确的函数。

## 第二章.原则

该章主要讲了重构的意义。

> 重构（名词）：对软件内部结构的一种调整，目的是<em>在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本</em>  
> 重构（动词）：使用一系列重构手法，<em>在不改变软件可观察行为的前提下，调整其结构</em>

#### 为何重构（好处）

- 改进设计：代码结构的设计，方案的设计，架构的设计等等，有助于整个软件（项目）的可持续发展
- 可读性：让代码更易于理解，方便修改
- 定位问题：重构可以让原本杂乱的结构变的条理有序，可以更好的将问题定位到某一块区域的代码
- 提升效率：对一些计算可进行优化，从而提升代码执行效率

#### 何时重构

- 预备性重构：在添加新功能前，发现原有功能设计不友好或者说满足不了之后的需求
- 帮助理解的重构：当看到既有代码，却难以理解其作用或意义的时候
- 有计划的重构：这个往往出现在对大的现有方案或设计进行重构，对当下的设计有很大程度的调整，也需要很大的成本时才会采取
- 长期重构：逐步的解决
- 复审代码：通过大家一起对代码审查，修改不合理的设计

#### 重构的条件

- 是否不影响新功能开发的进度
- 每个人是否都有对代码修改的权利
- 如何集成重构后的分支
- 是否有完善的测试机制支持

## 第三章.坏味道

该章主要是叙述了一些代码场景，当遇到这些情况，就可以去考虑是否需要去重构代码了（当然这个不是百分百，具体还是需要考虑实际情况，老司机凭经验~）,<em>该拆拆，该聚聚</em>

> 以下所有例子只是为来更好的理解，并不是最好（恰当）的例子

#### 神秘命名

不明确的命名，我们应该需要结合当下的业务场景，或者方法功能，编写一个直观明确的名称

```js
// ❌错误：不明确是什么状态
setStatus() {}
// ✅正确
setRoleStatus() {}
```

#### 重复代码

重复的代码需要提炼出来，使其可以共用

```js
// ❌错误
function fn1() {
  // do something
  if (status) {
    Notice.success("xxx");
  } else {
    Notice.fail("xxx");
  }
}

function fn2() {
  // do something
  if (success) {
    Notice.success("xxx");
  } else {
    Notice.fail("xxx");
  }
}
// ✅正确
function fn1() {
  // do something
  notice(status, message);
}

function fn2() {
  // do something
  notice(status, message);
}

function notice(status, message) {
  status ? Notice.success(message) : Notice.fail(message);
}
```

#### 过长函数

不应该把所有的功能都挤在一块，应该拆分开来，将不同功能的代码拆分成各个单一职责的函数方法。各种条件表达式和循环也是提炼的信号

```js
// ❌错误
function fn() {
  x的功能;
  y的功能;
  z的功能;
}
// ✅正确
function fn() {
  fnX();
  fnY();
  fnZ();
}
function fnX() {
  x的功能;
}

function fnY() {
  y的功能;
}
function fnZ() {
  z的功能;
}
```

#### 过长的参数列表

当一个函数有过多的参数，就需要考虑是否可以简化参数，如使用对象代替多个参数，或者看是否参数间有一些是可以通过另外的参数获取的，以此简化

```js
// ❌错误
function fn(a, b, c, d) {}
// ✅正确：参数就变成了可选
function fn({ a, b, c, d }) {}
// ✅正确：简化参数
function fn(a, b, c) {
  const d = this.list[a];
}
```

#### 全局变量

减少污染全局的变量，通过封装的方式解决

```js
// ❌错误
const status = false; // 全局
// ✅正确
function getStatus() {
  const status = false;
  return status;
}
```

#### 可变数据

不要去改变原有的数据，需要生成修改后的新数据，特别是引用类型，容易操作同一份数据而导致问题的出现

```js
const defaultPerson = {
  name: "zhangsan",
  age: 20,
};
// ❌错误
defaultPerson.age = 23;
// ✅正确
const person1 = { ...defaultPerson, age: 23 };
```

#### 发散式变化

当添加一项内容时，多处地方的逻辑都需要变化的时候。应该做到当对某个上下文做修改时，只需要理解当前这个上下文，而不必操心另一个。将处理一起的功能集合到一块，集合功能！

```ts
// ❌错误
function add(val: number) {
  val += "add";
  reduce(val);
}
function reduce(val: number) {
  val += "reduce";
  handle(val);
}
function handle(val: number) {
  console.log(val);
}
// 突然有一天，val要变成string,那么就要一个个改
// ✅正确
function add(val: string) {
  val += "add";
  val += "reduce";
  console.log(val);
}
```

#### 散弹式修改

当修改一处地方，就必须要同时修改多处地方的时候，就需要重构了。应该解耦或抽离相关的逻辑。

```js
// ❌错误
function fn1() {
  // x功能
  // do something
}
function fn2() {
  // base on x功能
  // do something
}
function fn3() {
  // base on x功能
  // do something
}
// ✅正确
function x() {
  // x功能
  // base on x功能
  return { ... }
}

function fn1() {
  x()
  // do something
}
function fn2() {
  x()
  // do something
}
function fn3() {
  x()
  // do something
}
```

#### 依恋情结

两个函数或者模块的数据交集过多的时候，就需要考虑是否抽离一个中间角色来间接处理

#### 数据泥团

太多的数据成团在一块，应该将它们提炼到独立对象中

```js
// ❌错误
let btnLoading = false
let btnText = '提交'
let btnDisabled = false
// ✅正确
let btnObj = {
  loading: false
  text: '提交'
  disabled: false
}
```

#### 基本类型偏执

可以将一些特殊的类型，如金钱、手机号等使用一个对象来处理，而不是直接使用一个字符串或者数字来表示

```js
// ❌错误
const phoneNumber = 15934908233;
// ✅正确
function PhoneNumber(val) {
  if (vaildPhone(val)) throw "...";
  const obj = {};
  let value = val;

  Object.defineProperty(obj, "value", {
    get() {
      return value;
    },
    set(newVal) {
      if (vaildPhone(newVal)) throw "...";
      value = newVal;
    },
  });
  return obj;
}

let number = PhoneNumber(159892947);
console.log(number.value);
number.value = 159892947;
```

#### 重复的switch

if/else和switch的写法实属让人觉得不舒服，可以利用一些方式优化代码，比如利用对象的形式

```js
// ❌错误
switch(key) {
  case: 'a': // ...
    break
  case: 'b': // ...
    break
  default
    break
}
// ✅正确
const group = {
  a: '...'
  b: '...',
  c: '...'
}
group[key]
```

#### 循环语句

用一些现有API或者自己封装API来简化一些for循环代码，比如特殊的filter,reduce等等

#### 多余的元素

减少一些不必要的类设计，通常会遇到一个简单的组件，大家也喜欢把它抽离出来，维护一个文件，而这对于后期开发是极不友好的，会导致嵌套过深不易阅读和数据不好处理的问题。应该使用内联的方式编写。

#### 夸夸其谈通用性

这个很多出现在一些封装的时候，想一口吃成大胖子，既想满足一些场景，又想满足另一些场景，最终导致整个“产品”难以使用。所以应该从好用实用的角度作为出发点，合理设计功能。

#### 过长的消息链

消息链过长往往不利用阅读和调试，组件封装也是同理，过多的嵌套也不合理。应该将一些功能聚合或者抽离出来

#### 中间人

如果一个方法被各处调用，并去实现不同事情的时候，就需要重构，一个方法应该做到单一功能化。这个在写代码的时候大家也都会遇到，就是一个封装好的组件，在被需求改变后，组件就只能为了不影响别的地方，而被迫加个参数来判断另一种功能。久而久之，不重构的话，项目就变成了一座屎山。

#### 内幕交易

其实也一样，就是抽离出两个组件交集的部分，解耦相关内容。

#### 过大的类

合理划分功能，拆解。

#### 异曲同工的类

说的就是多态，但是JS又没有多态的概念，所以这个场景还是比较少见。

#### 纯数据类

有点JavaBean的意思，但是对于js，我觉得没有必要，但是对于一些静态变量，是可以抽离出来成为一个文件的。

```js
const CHANGE_PAGE_STATUS = 'CHANGE_PAGE_STATUS'
```

#### 被拒绝的遗赠

关于类继承，在js平时开发中并不常用，如果你喜欢写服务端js，倒是可以注意下，运用委托取代子类，或者子类取代超类
#### 注释

优秀的代码是不需要注释的🐶，算了吧，没那么理想化的，面对复杂的业务需求，还是老老实实写注释吧！

## 第四章.构筑测试体系