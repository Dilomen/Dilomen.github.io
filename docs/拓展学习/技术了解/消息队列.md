## 概述

队列是一种先进先出的线性数据结构，那么消息队列也不例外。但是消息队列就在于消息二字，其主要功能是一种通信机制。

## 概念

### Broker

消息队列的服务进程，包含 Exchange + Queue

### Exchange

消息队列交换机，将消息转发按照规则到对应的队列

### Queue

消息队列，存储信息

### Producer

生产者，产生消息的一方

### Consumer

消费者，接受消息的一方

## 流程

<a data-fancybox title="'消息队列流程'" href="/拓展学习/消息队列流程.png">!['消息队列流程'](/拓展学习/消息队列流程.png)</a>

生产者 Producer 和服务进程 Broker 进行 TCP 连接，然后建立通道，发送的消息经过交换机 Exchange 来转发给 Queue 队列

消费者 Consumer 和服务进程 Broker 进行 TCP 连接，然后建立通道，一旦监听的 Queue 有消息，就接受到了

## 使用场景

### 异步处理

当一个事件处理完成后，本来可能是串行操作后面的流程，比如发送邮箱，发送短信。但是通过消息队列就可以并发处理

<a data-fancybox title="'消息队列同步异步'" href="/拓展学习/消息队列同步异步.jpg">!['消息队列同步异步'](/拓展学习/消息队列同步异步.jpg)</a>

### 解耦

一般请求往往在数据库（增删改查）异步操作完成后，再返回响应信息。但是加入了消息队列，就不需要去考虑关心数据库的操作，只需在加入消息队列后返回即可。继而将 2 个处理业务解耦

从应用场景中，一个订单系统和一个仓库系统，两者只要关心消息队列，而不用相互之间有直接关系

### 削峰

当请求量过大，服务承载不了的时候，特别是秒杀活动等，就可以对那些未能被服务处理的请求加入消息队列，从而解决高流量的问题，一般是设置消息队列的大小作为请求上限，一旦超出请求数量就不再接受更多的请求

## 问题

### 增加了架构复杂度

### 需要关心消息是否丢失或者重复问题

## 模式

### 功能排序

路由模式 > 发布订阅模式 > 工作模式 > 简单模式

### 简单模式

一个生产者一个消费者

<a data-fancybox title="'消息队列-简单模式'" href="/拓展学习/消息队列-简单模式.png">!['消息队列-简单模式'](/拓展学习/消息队列-简单模式.png)</a>

### 工作模式

一个生产者对应多个消费者，但是一个消息，只会被其中一个消费者处理，消息不会重复被消费，服务进程 Broker 会轮询顺序发给消费者，而不是每次都是同一个消费者

<a data-fancybox title="'消息队列-工作模式'" href="/拓展学习/消息队列-工作模式.png">!['消息队列-工作模式'](/拓展学习/消息队列-工作模式.png)</a>

```js
// 生产者
const topic = 'hello';
var amqp = require('amqplib/callback_api');
function publisher(conn) {
  // 创建通道
  conn.createChannel(on_open);
  function on_open(err, ch) {
    if (err != null) throw err;
    // 连接队列
    ch.assertQueue(topic);
    ch.sendToQueue(topic, Buffer.from('msg 01'));
    ch.sendToQueue(topic, Buffer.from('msg 02'));
  }
}

amqp.connect('amqp://guest:guest@localhost', function (err, conn) {
  publisher(conn);
});
```

```js
// 消费者
const topic = 'hello';
var amqp = require('amqplib/callback_api');

function consumer(conn) {
  conn.createChannel(on_open);
  function on_open(err, ch) {
    if (err != null) throw err;
    ch.assertQueue(topic);
    ch.consume(topic, function (msg) {
      if (msg != null) {
        console.log('consumer', msg.content.toString());
        ch.ack(msg);
      }
    });
  }
}

amqp.connect('amqp://guest:guest@localhost', function (err, conn) {
  consumer(conn);
});
```

### 发布订阅模式

一个生产者对应多个消费者,但是多一个交换机进行对消息转发到具体队列中，如果队列未绑定在交换机上，那么消息就会丢失。适用于一个消息被多个服务消费的场景，如一个消息，即需要发送短信，又需要发送邮件

<em>可以实现一个消息被多个消费者接收处理</em>

<a data-fancybox title="'消息队列-发布订阅模式'" href="/拓展学习/消息队列-发布订阅模式.png">!['消息队列-发布订阅模式'](/拓展学习/消息队列-发布订阅模式.png)</a>

```js
// 生产者
const ExchangeName = 'test-fanout';
var amqp = require('amqplib/callback_api');
function publisher(conn) {
  conn.createChannel(on_open);
  function on_open(err, ch) {
    if (err != null) throw err;
    // 声明交换机
    // fanout 发布订阅模式
    // direct 路由模式
    // topic 通配符（主题）模式
    // headers headers模式
    ch.assertExchange(ExchangeName, 'fanout', { durable: true });
    // 队列名 交换机名 路由Key
    ch.publish(ExchangeName, '', Buffer.from('通知'));
  }
}

amqp.connect('amqp://guest:guest@localhost', function (err, conn) {
  publisher(conn);
});
```

```js
// 消费者
const ExchangeName = 'test-fanout'
var amqp = require('amqplib/callback_api')

function consumer (conn) {
  conn.createChannel(on_open)
  function on_open (err, ch) {
    if (err != null) throw err
    ch.assertQueue('', { durable: true })
    ch.assertExchange(ExchangeName, 'fanout', { durable: true })
    ch.bindQueue('note', ExchangeName, '')
    ch.consume('note', function (msg) {
      if (msg != null) {
        console.log('consumer', msg.content.toString())
        ch.ack(msg)
      }
    })
  }
}

amqp.connect('amqp://guest:guest@localhost', function (err, conn) {
  consumer(conn);
})

// 多个消费者
...
ch.bindQueue('email', ExchangeName, '')
ch.consume('email', function (msg) {
  if (msg != null) {
    console.log('consumer', msg.content.toString())
    ch.ack(msg)
  }
})
...
```

### 路由模式

交换机会根据 routingKey 来转发到对应的队列

能够更加的自定义的选择队列发送消息

<a data-fancybox title="'消息队列-路由模式'" href="/拓展学习/消息队列-路由模式.png">!['消息队列-路由模式'](/拓展学习/消息队列-路由模式.png)</a>

```js
// 只需要在发布订阅模式上
// 修改成direct类型
ch.assertExchange(ExchangeName, 'direct', { durable: true });
// 绑定时注明routingKey即可
ch.bindQueue('email', ExchangeName, 'router');
```

### 通配符（主题）模式

交换机根据<em>统配符</em>匹配转发到相应的队列

#### 统配符

- <em>#</em>：可以匹配一个和多个词 如：a.# 可以匹配 a.b 和 a.b.c
- <em>\*</em>：只能匹配一个词 如 a.\* 不能匹配 a.b.c，只能匹配 a.b  
  （词以.分隔）

<a data-fancybox title="'消息队列-通配符模式'" href="/拓展学习/消息队列-通配符模式.png">!['消息队列-通配符模式'](/拓展学习/消息队列-通配符模式.png)</a>

```js
// 修改类型
ch.assertExchange(ExchangeName, 'topic', { durable: true });
ch.publish(ExchangeName, 'a.b.c', Buffer.from('通知'));
// 绑定时routingKey修改为对应通配符
ch.bindQueue('note', ExchangeName, 'a.*');
ch.bindQueue('email', ExchangeName, 'a.#');
```

## 确认机制

confirm 模式，是指当生产者发送消息给 Broker 服务进程，服务进程的确认反馈，生产者根据 ack 反馈知道消息是否发送成功，从而可以对消息进行相应的处理
