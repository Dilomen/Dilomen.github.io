## 网络编程

Node 提供了 4 个网络处理的模块

- net -> TCP
- dgram -> UDP
- http -> HTTP
- https -> HTTPS

## TCP

#### 服务器事件

- listening 绑定 port 或者 Domain Socket 后出发，server.listen(8124, () => {})
- connection 每个客户端连接到服务器服务端触发
- close 服务器关闭时（所有连接断开）触发
- error 捕获所有的异常

```js
var net = require('net');
var server = net.createServer(function(socket) {
  socket.on('data', () => {
    socket.write('你好');
  });
  socket.on('end', function() {
    console.log('连接断开');
  });
  socket.write('欢迎');
});
server.on('connection', function(socket) {
  // console.log(socket)
});
server.listen(8124, () => {
  console.log('server bound');
});
```

#### 连接事件

- data 接受另一端 write 发送的数据
- end 当连接中任意一端发送 FIN 数据触发
- connect 每个客户端连接到服务器服务端触发
- close 服务器关闭时（所有连接断开）触发
- drain 调用 write()发送数据就会触发
- error 捕获所有的异常
- timeout 当连接闲置（不在活跃）时触发

```js
var net = require('net');
var client = net.connect({ port: 8124 }, function() {
  client.write('world');
});
client.on('data', function() {
  client.end();
});
client.on('end', function() {
  console.log('client disconnected');
});
```

:::tip
TCP 采用 Nagle 算法，将小数据的内容进行合并才发出，进而优化网络
:::

## UDP

UDP 同样属于传输层，但是不需要想 TCP 一样进行连接才能发送数据，它不关心对方是否接受的到

```js
// 服务端
var dgram = require('dgram');
var server = dgram.createSocket('udp4');
server.on('message', function(msg, rinfo) {});

server.on('listening', function() {
  var address = server.address();
});

server.bind(41234);
```

```js
// 客户端
var dgram = require('dgram');
var message = new Buffer('深入浅出NodeJs');
var client = dgram.createSocket('udp4');
// 发送的Buffer，Buffer的偏移，Buffer的长度，目标端口，目标地址，发送完成后的回调
client.send(message, 0, message.length, 41234, 'localhost', function(
  err,
  bytes
) {});
```

## HTTP

由于采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，从而实现高并发

#### 服务端

一个 request 请求对象和一个 response 响应对象

- connextion 当客户端和服务端 TCP 连接建立时触发
- request 当客户端请求，解析出 HTTP 请求头时触发
- close 当所有连接断开时触发
- checkContinue 当客户端发送较大的数据时，不会立即发送，而是发送一个头部带有 Expect: 100-continue 的请求，这时便会触发 checkContinue 来决定是否允许上传。不监听改事件，默认返回 100 状态码就是允许，返回 400 就是不允许
- connect 当客户端发起 CONNECT 请求时触发，往往出现在请求代理
- upgrade 当客户端要求升级连接协议时触发
- clientError 连接的客户端触发 error 事件时，这个错误会传递到服务端

#### HTTP 客户端

```js
var options = {
  hostname: '127.0.0.1',
  port: 1334,
  path: '/',
  method: 'GET',
};
http.request(options, function(res) {
  console.log(res);
});
```

## WebSocket

#### Node 非常适合用于 WebSocket 技术的应用

- WebSocket 客户端的事件编程模式和 Node 相近
- Node 的事件驱动擅长和大量客户保持高并发的连接

#### WebSocket 相比较 HTTP 的优势

- 建立更少的连接，只建立一个 TCP 连接
- 支持服务端主动向客户端推送数据
- 更轻量级的请求头

#### 建立

先和 HTTP 一致，建立一个 TCP 连接，然后通过 HTTP 发送一个请求报文

```md
...
Upgrade: websocket
Connetion: Upgrade
...
```

就是这两个字段将会使得服务端升级协议为 Websocket，所以连接 websocket 的<em>握手阶段还是需要通过 HTTP 请求</em>的

## 网络安全
