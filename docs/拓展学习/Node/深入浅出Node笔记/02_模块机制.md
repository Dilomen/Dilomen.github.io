## CommonJS

Node 的实现是离不开 CommonJS，同时 CommonJS 也因 Node 的实现而广为人知

Node 中引入模块的经历过程

- 路径分析
- 文件定位
- 编译执行

模块分为<em>核心模块</em>（Node 提供的模块）和<em>文件模块</em>（用户编写的模块）

:::tip  
Node 会对引入过的模块进行缓存，且缓存的是编译和执行后的的对象，如果在此使用相同模块，就会直接使用对象，而不是再编译  
核心模块的缓存检查 优先于 文件模块的缓存检查  
:::

#### 路径分析

require(path)，path 可以分为

- 核心模块，如 http，fs 等
  - 直接读取 Node 已经编译好的二进制代码
- ./或../的相对路径文件模块
- /开头的绝对路径的模块
  - 相对路径和绝对路径都会被转成真实路径来查找具体文件地址
- 第三方依赖，如 express，body-parser 等
  - 首先查找当前文件夹下的 node_modules 目录
  - 如果没有就会查找父目录下的 node_modules 目录
  - 最终找到根目录下的 node_modules 目录
  - 因此文件嵌套越深，加载就越慢

#### 文件定位

对于以下 3 种后缀，Node 会自动添加并查找相应文件，顺序依次

- .js
- .json
- .node

但是为了 Node 可以更快的查找到对应文件，.json 和.node 后缀名还是最好加上，减少不必要的性能损耗

如果没有定位到相应文件，而是一个目录，在引入第三方依赖的时候经常出现，

- 先将该目录当做一个包
- 查看包下是否有 package.json 文件
- 如果存在，那么就将 package.json 的内容 JSON.parse 解析出来，取出 main 字段的相应值来确定文件主入口
- 如果 package.json 不存在或者 package.json 下 main 字段不存在，那么直接使用包下的 index.js 文件
- 如果上述都不存在，连 index.js，依次 index.json，index.node 还没有，那就直接报异常

## 模块编译

#### JS 模块编译

JS 文件会被包装以下形式，从而避免了全局污染

```js
(function(exports, require, module, __filename, __dirname) {
  // ...
});
```

最终通过一个 runInThisContext 来执行，通过 require 来抛出模块中的 exports 对象

#### C/C++模块编译

使用 Node 的 process.dlopen 来加载和执行，C/C++模块会被 JS 执行效率更高，但是开发难度也会比 JS 更高

#### JSON 模块编译

直接读取文件，通过 JSON.parse()方法返回一个对象

## NPM

包管理工具
