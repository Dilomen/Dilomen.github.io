## 多进程

Node 由于技术选型上决定了它是运行在单个进程单个线程上的

#### 优点

- 更加利于维护，状态单一
- 不会存在上下文切换带来的损耗

#### 缺点

- 无法利用多核 CPU 服务器
- 一个问题可能导致整个服务崩溃

## 多进程架构

### 复制进程

#### 主从模式

主进程

```js
// index.js
var fork = require('child_process').fork;
var cpus = require('os').cpus();
for (let i = 0; i < cpus.length; i++) {
  fork('./worker.js');
}
```

工作进程

```js
// worker.js
var http = require('http');
let port = Math.round((1 + Math.random()) * 10000);
http
  .createServer(function(req, res) {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Heelo World');
  })
  .listen(port, `127.0.0.1`, () => {
    console.log(`127.0.0.1:${port}`);
  });
```

> 该方式充分利用了多核，但不解决并发问题

### 进程间通信

父子进程间需要创建 IPC 通道才能通信，Node 实现 IPC 通道的方式是管道（pipe），具体由 libuv 提供，在 Window 下是命名管道，\*nix 下是 Domain socket，均可实现双向通信。

### 句柄传递

句柄： 句柄是一种可以用来标识资源利用的引用，它的内部包含了指向对象的文件描述符。如标识一个服务端的 socket 对象，一个 UDP 套接字等

带来的作用：原本每一个子进程都需要一个不同的端口号才能执行，但是有了句柄就可以让父进程将其的一些对象文件描述符（如 TCP 服务器）发送给子进程，那么子进程就可以和父进程监听同一个端口号了（以 TCP 服务器为例）

#### 如下代码，就可以让一个请求被相同端口下的不同进程进行处理

```js
// parent.js
var child = require('child_process').fork('./worker');
var server = require('net').createServer();
server.on('connection', (socket) => {
  socket.end('handled by parent\n');
});
server.listen(1337, () => {
  child.send('server', server);
});
```

```js
// worker.js
process.on('message', (m, server) => {
  if (m === 'server') {
    server.on('connection', (socket) => {
      socket.end('handled by child\n');
    });
  }
});
```

> 但是上述方案可能被父进程执行也可能被子进程执行，角色分配不是很好，希望父进程作为一个管理，而任务都交给子进程处理才是我们想要的

```js
// parent.js
var cp = require('child_process');
var child1 = cp.fork('./worker.js');
var child2 = cp.fork('./worker.js');

var server = require('net').createServer();
server.listen(1337, () => {
  child1.send('server', server);
  child2.send('server', server);
  server.close();
});
// worker.js
var http = require('http');
var server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('handled by child, pid is ' + process.pid + '\n');
});

process.on('message', (m, tcp) => {
  if (m === 'server') {
    tcp.on('connection', function(socket) {
      server.emit('connetion', socket);
    });
  }
});
```

- 由于创建不同的进程，TCP 服务端的 socket 套接字的文件描述符并不相同，所以监听相同的端口会抛出异常
- 发送句柄是发送文件描述符，描述符是相同就可以监听同一个端口，同时请求也只会被一个进程"抢到"执行
- Node 进程之间只有消息传递，不会真正地传递对象

## 集群

自动重启：保证有足够的进程来处理请求

```js
// parent.js
var fork = require('child_process').fork;
var cpus = require('os').cpus();
var server = require('net').createServer();
server.listen(1337);
var workers = {};
var createWorker = function() {
  var worker = fork('./worker.js');
  worker.on('message', function(message) {
    console.log(message);
    // 再一个异常进程退出前，创建一个新的进程来接受请求
    if (message.act === 'suicide') {
      createWorker();
    }
  });

  worker.on('exit', function() {
    console.log('Worker ' + worker.pid + ' exited.');
    delete workers[worker.pid];
  });
  worker.send('server', server);
  worker[worker.id] = worker;
  console.log('Create worker. pid ' + worker.pid);
};

for (let i = 0; i < cpus.length; i++) {
  createWorker();
}

process.on('exit', function() {
  for (let pid in workers) {
    workers[pid].kill();
  }
});
// worker.js
var http = require('http');
var server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('handled by child, pid is ' + process.pid + '\n');
});
var worker;
process.on('message', (m, tcp) => {
  if (m === 'server') {
    worker = tcp;
    tcp.on('connection', function(socket) {
      server.emit('connetion', socket);
    });
  }
});

process.on('uncaughtException', function() {
  process.send({ act: 'suicide' });
  // 停止接受新的连接
  worker.close(function() {
    process.exit(1);
  });
  setTimeout(function() {
    process.exit(1);
  }, 500);
});
```

```shell
Create worker. pid 5070

kill 5070

Create worker. pid 5080
Worker 5070 exited.
```

## Cluster 模块

以上的所有进程方式，其实 Node 本身就有对应的模块进行处理————Cluster

Cluster 实质还是通过 net 和 child_process 来实现的。当子进程 listen 端口时，就会拿到相同的文件描述符，从而实现多个子进程共享端口

```js
// parent.js
var cluster = require('cluster');
var cpus = require('os').cpus();

cluster.setupMaster({
  exec: './worker.js',
});

for (let i = 0; i < cpus.length; i++) {
  cluster.fork();
}

cluster.on('fork', (worker, code, signal) => {
  console.log('worker ' + worker.process.pid + ' fork');
});

cluster.on('exit', (worker, code, signal) => {
  console.log('worker ' + worker.process.pid + ' died');
  cluster.fork();
});

// worker.js
var http = require('http');
http
  .createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('handled by child, pid is ' + process.pid + '\n');
  })
  .listen(8000);
```
