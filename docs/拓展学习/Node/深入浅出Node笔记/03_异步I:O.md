## 异步 I/O

异步 I/O 是 Node 的一大特色，也是其非阻塞 I/O 的一种实现方法

由于 Node 是单线程（JS 层），所以必须串行执行任务，那么一个 I/O 操作的阻塞就会造成 CPU 的资源浪费，所以异步 I/O 可以让单线程远离阻塞，更好的利用 CPU

单线程的场景下

- **阻塞 I/O**  
  在 I/O 调用结束前，不能进行别的任务的执行，造成 CPU 等待，浪费资源
- **非阻塞 I/O**  
   发起 I/O 调用后，立即返回，返回后即可执行别的任务  
   但是返回的只是状态，而不是完整的数据，之后需要通过轮询的方式去查看数据是否获取完全
  > 注：轮询是一种比较性能低的方式，理想的是通过 I/O 完成后主动返回给应用程序，就不需要每次查看是否数据完整

## Node 中的实现

虽然 Node 的上层（JS 层）是单线程，但是下层（C++）则是多线程，其 I/O 处理会交给底层的线程池处理

#### 事件循环

这个词对于前端并不陌生，但是 EventLoop 在浏览器同样存在，但是两端还是有区别的

- 浏览器端:  
  宏任务 -> 所有微任务 -> 宏任务 -> 所有微任务

- node:  
   一个阶段的宏任务微任务 -> 一个阶段的宏任务微任务

> 这里不做过多叙述

#### 观察者

事件循环是一个**生产者/消费者模型**，异步 I/O 和网络请求等是事件的生产者，并有观察者判断当前是否有事件，有则执行

#### 请求对象

当我们代码使用 Node 的 API 进行 I/O 处理时，其会先调用 C++内建模块，然后通过 libuv 进行系统调用。JS 的调用会立即返回，这时就可以执行别的任务，而 I/O 操作会在线程池中等待执行，从而不阻塞别的任务的执行

#### 执行回调

当线程池中的 I/O 操作执行完毕后，就会通过对应的方法，通知上层，将线程池中有执行完的请求放入 I/O 观察者队列，I/O 观察者观察到队列中有待处理的事件，就会执行

## api

process.nextTick 和 setImmediate 是 node 异步特有的 api

两者都会比 setTimeout 性能更优，process.nextTick优先级高于setImmediate

- process.nextTick
  - 属于idle观察者，先于I/O观察者
  - 回调是保存在一个数组中
  - 每轮循环，会将数组中的回调函数全部执行完
- setImmediate
  - 属于check观察者，后于I/O观察者
  - 回调是保存在一个链表中
  - 每轮循环，只执行链表中的一个回调函数
