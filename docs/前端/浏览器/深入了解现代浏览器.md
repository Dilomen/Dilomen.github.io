## 概述

现代浏览器的功能日渐强大，Chrome 更是“独树一帜”，对于浏览器的认识能让我们的认知和对于一些性能提升都有很大的帮助

本文主要是对[Inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part1)文章的收获总结

## 进程和线程

> 以 Chrome 为例

#### Chrome 有 4 个进程，分别是<em>浏览器进程，渲染进程，插件进程，GPU 进程</em>

| 线程             | 作用                                                               |
| ---------------- | ------------------------------------------------------------------ |
| Browser Process  | 控制 chrome 应用部分，即提供的地址栏，书签，历史记录，文件访问等等 |
| Renderer Process | 每个窗口页面的展示                                                 |
| Plugin Process   | 控制网站的所有插件，如 flash                                       |
| GPU Process      | 处理 GPU 相关任务                                                  |

<a data-fancybox title="chrome进程" href="/前端/chrome进程.png">![chrome进程](/前端/chrome进程.png)</a>

> 摘自 [https://developers.google.com/web/updates/2018/09/inside-browser-part1](https://developers.google.com/web/updates/2018/09/inside-browser-part1)

打开【更多工具】-> 【任务管理器】就可以看到浏览器当前跑的进程

#### 由图可以看到每个标签页和插件都会创建独立的一个进程

:::tip 那么为什么要这设计呢,会不会太浪费资源
这主要是为了提升体验而不得不做的选择，因为进程都是独立空间的，可以保证一个页面的崩溃不会影响另一个页面。

当然 chrome 也不会无限制的创建进程，当到达一定的范围（取决于设备的内存和 CPU 能力）时，它就会<em>将同一个站点的标签页放到同一个进程</em>

当然为当设备条件不允许资源匮乏下的情况下，Chrome 为了节省资源会选用以下其中一种

- Process-per-site-instance (default) - 同一个 site-instance 使用一个进程
- Process-per-site - 同一个 站点 使用一个进程
- Process-per-tab - 每个 tab 使用一个进程
- Single process - 所有 tab 共用一个进程

##### <em>site 同站</em>（同一个站点）：就是域名和协议一样，如 a.baidu.com 和 b.baidu.com,且都是 https

##### <em>site-instance</em>：就是通过 JS 代码（如 window.open）或者 HTML（如\<a\ target="\_blank">）打开的同 site 页面

:::

> <a data-fancybox title="chrome正在跑的进程" href="/前端/chromeProcessRunning.png">![chrome正在跑的进程](/前端/chromeProcessRunning.png)</a>

当设备硬件有很大的支持下，Chrome 会将各个服务<em>拆分成不同的服务进程</em>，以此来提供更高的稳定性，正如上图所示的 Network Service，Storage Service 都是属于服务进程。但是当设备条件不允许下，那么为了节省内存，Chrome 会将这些服务进程组合成一个进程
<a data-fancybox title="chrome服务进程" href="/前端/chrome服务进程.png">![chrome服务进程](/前端/chrome服务进程.png)</a>

> 摘自 <https://developers.google.com/web/updates/2018/09/inside-browser-part1>

:::tip 网站隔离

每一个嵌套在页面的 iframe 页面也会有一个独立的渲染器进程（Renderer Process）
:::

#### 浏览器进程有 3 个线程

| 线程           | 作用                           |
| -------------- | ------------------------------ |
| UI thread      | 用于绘制浏览器的按钮和输入字段 |
| network thread | 用于对网络的数据处理           |
| storage thread | 用于控制对文件的访问           |

## 导航请求

导航栏输入
1、当在导航栏输入内容后确认，浏览器会先<em>判断内容</em>是 URL 还是搜索查询？

- 搜索查询，将内容交给搜索引擎，开始搜索
- URL，开始 DNS 解析、建立 TLS 连接等等的一系列操作

2、UI 线程告知 network 线程，<em>请求资源</em>

3、network 线程读取相应内容，就会告知 UI 线程，如果是 HTML 就开始进行渲染，如果是文件，就进入下载请求

4、然后 UI 线程就会让浏览器进程通过 IPC 来调度渲染器进程及向其发送数据流（包括 HTML 等），整个导航就完成了，<em>文档开始加载</em>

5、当遇到 HTML 内部需要加载资源的时候，渲染器进程会通知浏览器进程去执行网络线程来请求资源

6、当页面加载完成，渲染器进程就会通知浏览器进程

## 页面渲染

渲染器进程的主要工作就是将 HTML，CSS，js 的代码转化为可以与用户交互的页面
:::tip JS 为什么会阻塞代码的执行
因为 JS 有控制 DOM 的能力，如果 HTML 和 JS 同时执行的话会混乱，所以当遇到 JS 代码时，会阻塞 HTML 的加载
:::

1、首先渲染器进程会收到浏览器发送过来的 HTML 内容，并生成 document 对象，即<em>生成 DOM 树</em>

2、接着进程下的主线程开始执行<em>计算 CSS 样式</em>，并赋给 DOM 树

3、开始<em>计算布局方位</em>，确定元素的位置，生成 Layout 树

4、确定<em>渲染顺序</em>，先是背景，再试文字，再确定矩形

5、最后渲染页面，将页面的各个部分分成若干份（栅格化），组合成 60fps 频率的帧来展示页面，如果发生滚动，就会组<em>合成新的帧</em>

<a data-fancybox title="chrome渲染合成" href="/前端/chrome渲染合成2.gif">![chrome渲染合成](/前端/chrome渲染合成2.gif)</a>

> 合成就是若干份的页面合成成一个页面

<a data-fancybox title="chrome渲染合成" href="/前端/chrome渲染合成.gif">![chrome渲染合成](/前端/chrome渲染合成.gif)</a>

> 滚动的话，就光栅化更多的页面来补充缺失的部分，形成新的帧进行渲染

<a data-fancybox title="chrome渲染合成" href="/前端/chrome渲染合成3.png">![chrome渲染合成](/前端/chrome渲染合成3.png)</a>

## 事件处理
