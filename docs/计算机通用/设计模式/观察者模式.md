## 什么是观察者模式

观察者模式就是维护一个对象和一个观察者队列，当这个对象发生改变时，所有的观察者都会得到通知，是一对多的依赖关系

<a data-fancybox title="观察者模式" style="width: 400px;display: inline-block" href="/计算机通用/观察者模式.png">![观察者模式](/计算机通用/观察者模式.png)</a>

## 什么是发布订阅模式

由于两个模式比较相似，所以放在一起比较，发布订阅模式其实是观察者模式的升级，一个是发布者队列，一个是订阅者队列，两者通过中间的“控制器”来使订阅者接受到通知，而发布者和订阅者本身是解耦的

<a data-fancybox title="发布订阅模式" style="width: 400px;display: inline-block" href="/计算机通用/发布订阅模式.png">![发布订阅模式](/计算机通用/发布订阅模式.png)</a>

:::tip 小插曲
DOM 绑定事件 addEventListener 也是发布订阅模式

<a data-fancybox title="DOM绑定事件" href="/计算机通用/DOM绑定事件.png">![DOM绑定事件](/计算机通用/DOM绑定事件.png)</a>
:::

## 简单实现

#### 观察者模式

```js
function Observer() {
  this.listeners = {};
}
Observer.prototype.listen = function (type, func) {
  if (!(this.listeners[type] instanceof Array)) {
    this.listeners[type] = [];
  }
  this.listeners[type].push(func);
};
Observer.prototype.remove = function (type, func) {
  if (!this.listeners[type]) {
    return;
  }
  let len = this.listeners[type].length;
  for (let i = len - 1; i >= 0; i--) {
    if (this.listeners[type][i] == func) {
      this.listeners[type].splice(i, 1);
    }
  }
};
Observer.prototype.trigger = function (type) {
  let len = this.listeners[type].length;
  for (let i = 0; i < len; i++) {
    this.listeners[type][i]();
  }
};

function say1() {
  console.log('a1');
}
function say2() {
  console.log('a2');
}
function say3() {
  console.log('a3');
}
var observer = new Observer();
observer.listen('a', say1);
observer.listen('a', say2);
observer.listen('a', say3);
observer.remove('a', say1);
observer.trigger('a'); // a2 a3
```

#### 发布订阅模式

```js
var Observer = {
  listen: {},
  resigt: function (question, answer) {
    if (!(this.listen[question] instanceof Array)) {
      this.listen[question] = [];
    }
    this.listen[question].push(answer);
  },
  fire: function (question, ...arg) {
    this.listen[question].forEach((fn) => fn(...arg));
  },
};
function Student(result) {
  let _that = this;
  this.result = result;
  this.say = function () {
    console.log(_that.result);
  };
}

Student.prototype.answer = function (question) {
  Observer.resigt(question, this.say);
};

function Teacher() {}
Teacher.prototype.ask = function (question) {
  Observer.fire(question);
};

var studentA = new Student('学生A回答问题');
var studentB = new Student('学生B回答问题');
var studentC = new Student('学生C回答问题');
studentA.answer('什么是XXX');
studentB.answer('什么是XXX1');
studentC.answer('什么是XXX');

var teacher = new Teacher();
teacher.ask('什么是XXX'); // 学生A回答问题 学生C回答问题
```

## 对象属性的观察

```js
var a = {};
var temp = null;
Object.defineProperty(a, 'b', {
  get: () => {
    console.log(temp);
    return temp;
  },
  set: (newValue) => {
    console.log(newValue);
    temp = newValue;
  },
});
a.b = 234; // 当改变属性的时候，就会触发对应的set方法，取值的时候就是触发get方法
```
