---
title: 代理模式
tags: 设计模式
categories: 设计模式
keywords: 代理模式,js,设计模式
description: 代理模式
date: 2020-02-22 19:56:45
---

## 简介

:::tip

- 为访问的对象提供一个代替品，当你需要去访问该对象时，只需要去访问这个代替品就可以了，相当于是一个中介
- 该模式往往处理你对访问对象某种状态不明确的情况下，需要让代理来进行操作
  :::

> ### 外观模式，代理模式，中介者模式的区别？

- 首先三者是很相似的，都是引入了第三者。
- 外观模式和代理模式都是结构型模式，而中介者模式是行为型模式。也就是说前两者都不会对原有处理事件增加新的事件处理，而是在原有事件处理上的"优化"，中介者则是添加了新的处理事件
- 外观模式是对**被访问对象**进行简化，将一些复杂的进行隐藏，以便更好的访问，如代码兼容处理
- 代理模式是用一个代理类来替代另一个类的功能，控制被代理类的访问，如图片加载添加占位
- 中介者模式是为了两个对象的交互更加独立，用以解耦为目的，将对象之间的**网状结构转变为星型结构**，如 MVVM 框架，ViewModal 就是中介者

## 简单实现

以下就是一个代理的过程，当然实际肯定不会像下面简单，这么简单在使用代理模式就是一种浪费了

```js
var A = {
  send: function() {
    agency();
  },
};

var agency = function() {
  // XX操作
  B.receive();
};

var B = {
  receive: function() {
    console.log('接收成功');
  },
};

A.send();
```

## 虚拟代理

虚拟代理是将一些开销比较打的对象进行延迟加载，比如图片加载，可以在图片加载完成前先用如加载图片所占位

```js
let myImage = (function() {
  let imgNode = document.createElement('img');
  document.body.appendChild(imgNode);
  return {
    setSrc: function(src) {
      imgNode.src = src;
    },
  };
})();

let proxyImage = (function() {
  let img = new Image();
  img.onload = function() {
    myImage.setSrc(this.src);
  };
  return {
    setSrc: function(src) {
      myImage.setSrc('loading.gif');
      img.src = src;
    },
  };
})();

proxyImage.setSrc('pic.jpg');
```

## 缓存代理

对于一些经常重复性的处理结果，可以做缓存代理，当再次处理相同内容时，直接返回缓存中的结果，可以对一些**不需要实时查看**的分页进行缓存代理，减少 http 请求

```js
let cacheProxy = (function() {
  let cache = {};
  return function() {
    var key = '生成处理内容的字符串，如1*1';
    if (key in cache) {
      return cache[key];
    }
    cache[key] = '处理结果';
  };
})();

cacheProxy('...');
```
