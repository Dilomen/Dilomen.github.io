---
title: 工厂模式
tags: 设计模式
categories: 设计模式
keywords: 工厂模式,js,设计模式
description: 设计模式
abbrlink: 54788f73
date: 2019-08-24 15:59:31
---

## 简述

- 工厂模式按照抽象程度分为**简单工厂模式**，**工厂模式**，**抽象工厂模式**
- 就是将生成对象的逻辑包装起来，利用“工厂”来生产你想要的对象
- 实际应用场景： 不同登录角色的权限

## 简单工厂模式

- 就是创建一个函数，传入一个“需求”，让工厂来直接生产该需求的对象

```js
let createFactory = function(type) {
  function Admin() {
    this.name = "管理员";
    this.limit = 0;
  }
  function Vip() {
    this.name = "vip";
    this.limit = 1;
  }
  function User() {
    this.name = "普通用户";
    this.limit = 2;
  }
  switch (type) {
    case "Admin":
      return new Admin();
    case "Vip":
      return new Vip();
    case "User":
      return new User();
    default:
      throw new Error("必须传入角色类别，Admin | Vip | User");
  }
};
```

- 简化代码：

```js
let createFactory = function(type) {
  function User(name, limit) {
    this.name = name;
    this.limit = limit;
  }
  switch (type) {
    case "Admin":
      return new User("管理员", 0);
    case "Vip":
      return new User("vip", 1);
    case "User":
      return new User("普通用户", 2);
    default:
      throw new Error("必须传入角色类别，Admin | Vip | User");
  }
};
let user = createFactory("Admin");
```

- 总结：

  - 优点：逻辑简单清晰
  - 缺点：如果“需求“越多，工厂就要有更多的“产品线”，会使这个 createFactory 函数过于拥挤，不好维护

## 工厂模式

-鉴于简单工厂的”不好维护“，工厂模式就是将”产品线“（实现对象的业务逻辑）外包出去,在 js 中就是将这些”产品线“方法原型函数上去

```js
let createFactory = function(type) {
  // 此时的this是指向createFactory生成的对象
  if (this instanceof createFactory) {
    let obj = new this[type]();
    return obj;
  } else {
    // 必须先生成对象才能直接调用原型链上的方法
    return new createFactory(type);
  }
};
createFactory.prototype = {
  Admin: function() {
    this.name = "管理员";
    this.limit = 0;
  },
  Vip: function() {
    this.name = "vip";
    this.limit = 1;
  },
  User: function() {
    this.name = "普通用户";
    this.limit = 2;
  }
};
let user = createFactory("Admin");
```

或者

- 总结：

  - 优点：降低解耦，更利于维护

## 抽象工厂模式

- 首先 js 并没有关键字 abstract 的实现方法
- 可以通过父类抛出异常来模拟抽象类，即如果子类没有覆盖父类的这个方法，就会报错

```js
let inherit = function(subType, superType) {
  subType.prototype = new superType();
  subType.constructor = subType;
};

let AbstractFactory = function(subType, superType) {
  if (typeof AbstractFactory[superType] === "function") {
    inherit(subType, AbstractFactory[superType]);
  } else {
    throw new Error("没有抽象类");
  }
};

AbstractFactory.Admin = function() {
  this.name = "管理员";
};
AbstractFactory.Admin.prototype = {
  getName: function() {
    return new Error("Admin抽象类没有实现");
  }
};

AbstractFactory.Vip = function() {
  this.name = "vip";
};
AbstractFactory.Vip.prototype = {
  getName: function() {
    return new Error("Vip抽象类没有实现");
  }
};

AbstractFactory.User = function() {
  this.name = "普通用户";
};
AbstractFactory.User.prototype = {
  getName() {
    throw new Error("User抽象类没有实现");
  }
};

function User() {
  AbstractFactory.User.call(this);
  this.limit = 2;
}
AbstractFactory(User, "User");
User.prototype = {
  getName: function() {
    return this.name;
  }
};
let user = new User();
console.log(user);
```

- 总结
  - 通过对业务逻辑更抽象化，方便实现多种需求的转换，适合大型多人开发

## 总结

简单工厂模式，已经能够解决前端很多的业务场景，但是为了更好的维护还是使用工厂模式，如果业务”产品线“真的很多，且可能有不同的业务实现，那么就使用抽象工厂模式
