## 简述

策略模式就是在不同的方案中选择一种进行操作

:::tip

#### 策略模式和简单工厂模式的区别

初学者很容易将两者的解释混为一谈，都觉得是传入一些内容，生成一些内容。
而两者其实是有很大的差别的

- 策略模式是行为型模式，简单工厂模式是创建型模式，就是说策略模式是根据传参执行对应的一个行为操作，是为了不同行为方式的封装，而简单工厂模式是根据传参生成一个所需的对象
- 策略模式是“白盒”，后续操作可以根据不同的行为继续操作，而简单工厂模式是“黑盒”，你不需要关心里面发生了什么，只需要获得使用创造出来的对象
  :::

## 实现

JS 对于策略模式有天生的优势，因为 JS 对象恰恰可以满足策略模式的需求

```js
const strategies = {
  A: () => {
    console.log('A');
  },
  B: () => {
    console.log('B');
  },
  C: () => {
    console.log('C');
  },
};
strategies('A');
```

当然也可以利用 JS 函数作为一等公民的优势

```js
function A() {
  return 'A';
}
function B() {
  return 'B';
}
function C() {
  return 'C';
}
function strategies(strategy) {
  console.log(strategy());
}
strategies(A);
```

## 应用

策略模式在 JS 中还是应用很多的，比如表单验证或者是表单组件封装

```js
function vaildFunc(form) {
  if ('rule1') {
    // do something
    return false;
  }
  if ('rule2') {
    // do something
    return false;
  }
  if ('rule3') {
    // do something
    return false;
  }
  return true;
}
```

```js
function form(type) {
  switch (type) {
    case 'button':
      return <Button></Button>;
    case 'switch':
      return <Switch></Switch>;
    case 'checkbox':
      return <Checkbox></Checkbox>;
    default:
      break;
  }
  return null;
}
```

经常见到这种 if， switch 大部队吧，那么就可以使用策略模式来优化代码

```js
const vaildObj [
  () => 'rule1',
  () => 'rule2',
  () => 'rule3'
]

function vaildFunc(form) {
 return !vaildObj.some(fn => fn())
}
```

```js
const strategies = {
  button: () => <Button></Button>;
  switch: () => <Switch></Switch>;
  checkbox: () => <Checkbox></Checkbox>;
}
function form(type) {
  if (strategies.hasOwnProperty(type)) {
    return strategies[type]()
  }
  return null
}
```

如果 value 部分的代码很多，就不建议直接把所有内容直接写在对象，而是单独抽离成上述展示的一个个方法，将方法名作为 value 值作为引用，更加利于扩展及代码美化
