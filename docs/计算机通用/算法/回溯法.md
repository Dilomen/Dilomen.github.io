## 概述

回溯法是向前探索一步，处理相关的逻辑，如果不符合或者没有达到目标，就返回一步重新选择，最终达到目标。

常用于：组合、排列、切割、子集

## 伪代码

```js
function backtrack(nums) {
  dfs([], nums);
  return result;
}

function dfs(current, arr) {
  if (condition) {
    // 需要拷贝处理，不如会影响
    fn(cloneDeep(current));
    return;
  }
  for (let i = 0; i < arr.length; i++) {
    current.push(arr[i]);
    // do something
    dfs(current, temp, result);
    // 回退到上一步
    current.pop();
  }
}
```

## 实战

[全排列](https://leetcode-cn.com/problems/permutations/submissions/)

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const result = [];
  dfs([], nums, result);
  return result;
};

function dfs(current, arr, result) {
  if (arr.length === 0) return result.push(current.slice());
  for (let i = 0; i < arr.length; i++) {
    current.push(arr[i]);
    const temp = [...arr];
    temp.splice(i, 1);
    dfs(current, temp, result);
    current.pop();
  }
}
```

**空间换时间**

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const result = [];
  dfs([], nums, result);
  return result;
};

function dfs(current, arr, result) {
  if (arr.length === 0) {
    return result.push(current);
  }
  for (let i = 0; i < arr.length; i++) {
    const currentTemp = [...current, arr[i]];

    const temp = [...arr];
    temp.splice(i, 1);

    dfs(currentTemp, temp, result);
  }
}
```
