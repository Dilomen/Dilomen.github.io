## 概述

BFS（ Breadth First Search 广度优先算法 ）通过搜索旁边的节点，将旁边的节点作为一个队列，遍历完再进行旁边的旁边节点的遍历。

## 伪代码

```js
function breadthFirstSearch(grid) {
  let queue = []; // 需要遍历的队列
  const gridLen = grid.length;
  const visited = new Map() | new Set() | new Array(); // 标记节点是否被浏览过,视情况定数据结构
  queue = getSideNodeList(); // 获取旁边的节点
  while (!queue.length) {
    const node = queue.shift(); // 需要遍历的节点出队列
    visited(node); // 标记该节点已被访问
    if (node) { // 符合要求
      queue.push(node.getSideNodeList()); // 就处理该节点旁边节点
    }
  }
}
```

## 例题 1

> [省份数量](https://leetcode-cn.com/problems/number-of-provinces)

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

```js
/**
 * @param {number[][]} isConnected
 * @return {number}
 */
var findCircleNum = function(isConnected) {
  if (!isConnected || !isConnected.length) return 0;
  const cityLen = isConnected.length;
  const visited = new Array(cityLen).fill(false);
  let result = 0;
  let queue = [];
  for (let i = 0; i < cityLen; i++) {
    if (!visited[i]) {
      ++result;
      queue.push(i);
      while (queue.length) {
        const k = queue.shift();
        visited[k] = true;
        for (let j = 0; j < cityLen; j++) {
          // 查询当前城市的相连城市
          if (isConnected[k][j] === 1 && !visited[j]) {
            queue.push(j);
          }
        }
      }
    }
  }
  return result;
};
```
