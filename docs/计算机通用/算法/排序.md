## 概述

排序是经常使用到的一种整理数据的方式，其在程序中也经常被使用到

那么什么样的数据是可以被排序的？必须有一个可以比较的主键，根据主键的比较规则进行排序

> 即便是偷懒，使用高级语言提供的排序 API 还是使用一些方法库，我们还是需要从最基本的原理来了解各种排序的机制

## 八大排序

| 名称     | 时间复杂度 | 时间复杂度最坏 | 时间复杂度最快 | 稳定性 |
| -------- | ---------- | -------------- | -------------- | ------ |
| 冒泡排序 | O(n^2)     | O(n^2)         | O(n)           | 稳定   |
| 选择排序 | O(n^2)     | O(n^2)         | O(n)           | 不稳定 |
| 插入排序 | O(n^2)     | O(n^2)         | O(n)           | 稳定   |
| 希尔排序 | O(n^1.5)   | O(n^2)         | O(n)           | 不稳定 |
| 快速排序 | O(nlogN)   | O(n^2)         | O(nlogN)       | 不稳定 |
| 归并排序 | O(nlogN)   | O(nlogN)       | O(nlogN)       | 稳定   |
| 堆排序   | O(nlogN)   | O(nlogN)       | O(nlogN)       | 不稳定 |
| 基数排序 | O(n\*k)    | O(n\*k)        | O(n\*k)        | 稳定   |

> 稳定性：相同的两个值是否会调换位置，稳定表示不会调换，不稳定表示会调换  
> 例：如果数组中有两个 10，排序后，后面的 10 变成了前面，这就是不稳定

## 初级排序算法

### 冒泡排序

#### 和后面相邻的相比较，按比较规则转换位置，进入下一个，再和后面的相邻比较，每轮选出一个最（大或小）值

<a data-fancybox title="冒泡排序" href="/计算机通用/bubble_sort.png">![冒泡排序](/计算机通用/bubble_sort.png)</a>

```js
var arr = [1, 4, 13, 7, 2, 9, 1, 1];

function exch(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function bubbleSort(arr) {
  let len = arr.len;
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        exch(arr, j, j + 1);
      }
    }
  }
  return arr;
}

console.log(bubbleSort(arr)); //  [1, 1, 2, 4, 7, 9, 9, 13]
```

### 选择排序

#### 和后面的每一个元素进行比对，每轮将一个最（大或小）值确定

<a data-fancybox title="选择排序" href="/计算机通用/choose_sort.png">![选择排序](/计算机通用/choose_sort.png)</a>

```js
var arr = [1, 4, 13, 7, 2, 9, 1, 1];

function exch(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function chooseSort(arr) {
  let len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    for (let j = i + 1; j < len; j++) {
      if (arr[i] > arr[j]) {
        exch(arr, i, j);
      }
    }
  }
  return arr;
}

console.log(chooseSort(arr)); //  [1, 1, 2, 4, 7, 9, 9, 13]
```

#### 优化版

存取最小的值，比较结束替换位置，减少位置的移动

```js
function chooseSort(arr) {
  let len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (arr[minIndex] < arr[j]) {
        minIndex = j;
      }
      exch(arr, i, j);
    }
  }
  return arr;
}
```

### 插入排序

#### 将当前的值和前面已经排好的数值进行比较，插入到已经排好序列中相应的位置

<a data-fancybox title="插入排序" href="/计算机通用/insert_sort.png">![插入排序](/计算机通用/insert_sort.png)</a>

```js
var arr = [1, 4, 13, 7, 2, 9, 0, 1];

function exch(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function insertSort(arr) {
  let len = arr.length;
  for (let i = 1; i < len; i++) {
    for (let j = i; j >= 0; j--) {
      if (arr[j] < arr[j - 1]) {
        exch(arr, j, j - 1);
      } else {
        break;
      }
    }
  }
  return arr;
}
console.log(insertSort(array)); //  [1, 1, 2, 4, 7, 9, 9, 13]
```

#### 优化版

找到位置点，在进行转换，将中间的转换变为赋值操作，相当于两次变一次

```js
function insertSort(arr) {
  let len = arr.length;
  let content, preIndex;
  for (let i = 1; i < len; i++) {
    content = arr[i];
    preIndex = i;
    for (let j = i - 1; j >= 0; j--) {
      if (arr[j] < content) break;
      arr[j + 1] = arr[j];
      preIndex = j;
    }
    arr[preIndex] = content;
  }
  return arr;
}
```

### 希尔排序

#### 插入排序的升级版，交换规定位数之间的数据比较及转换，规定的间隔数会递减到 1 为止

如果最小或者最大的在一端，而排序规则是将其到另一端，那么选择队列就需要移动(n-1)个位置，而需要是按希尔排序指定的格数交换，就只需要移动(n/间隔数)个位置

<a data-fancybox title="希尔排序" href="/计算机通用/shell_sort.png">![希尔排序](/计算机通用/shell_sort.png)</a>

```js
function shellSort(arr) {
  let len = arr.length;
  let h = 1,
    preIndex,
    content;
  while (h < len / 3) h = 3 * h + 1; // 1, 4, 13, 40.....
  while (h >= 1) {
    for (let i = h; i < len; i++) {
      content = arr[i];
      preIndex = i;
      for (let j = i - h; j >= 0; j -= h) {
        if (arr[j] < content) break;
        arr[j + h] = arr[j];
        preIndex = j;
      }
      arr[preIndex] = content;
    }
    h = parseInt(h / 3);
  }
  return arr;
}
```

## 归并算法

#### 将排序的数组分成更小的数组，最后将这些数组组合

<a data-fancybox title="归并排序" href="/计算机通用/merge_sort.png">![归并排序](/计算机通用/merge_sort.png)</a>

```js
function mergeSort(arr) {
  sort(arr, 0, arr.length - 1);
  return arr;
}

function sort(arr, low, high) {
  if (low >= high) return;
  let mid = Math.floor((high + low) / 2);
  sort(arr, low, mid);
  sort(arr, mid + 1, high);
  merge(arr, low, high);
}

function merge(arr, low, high) {
  let newArr = [];
  let mid = Math.floor((high + low) / 2);
  let j = mid + 1,
    i = low,
    k = low;
  while (i <= mid && j <= high) {
    if (arr[i] < arr[j]) {
      newArr[k++] = arr[i++];
    } else {
      newArr[k++] = arr[j++];
    }
  }
  while (i <= mid) {
    newArr[k++] = arr[i++];
  }
  while (j <= high) {
    newArr[k++] = arr[j++];
  }
  for (let cloneLow = low; cloneLow <= high; cloneLow++) {
    arr[cloneLow] = newArr[cloneLow];
  }
}
```

## 快速排序

#### 快速排序：随便找个基准数，然后从数组的左边和右边开始遍历，比基准数小的放左边，比基准数大的放右边，切换基准数，再次...

> 实现：选取一个基准数，右边开始向左扫描，如果左一个比它大的停止，左边开始向右扫描，如果右一个比它小的停止，然后将左
> 边大的和右边小的进行交换，再继续这样向中间扫瞄，如果扫到中间相遇了，那就将中间的这个和基准数进行交换，成为新的基准数，
> 接着可以通过递归将原中间值的位置划分为左右子数组，再在子数组中进行上述操作，再通过递归划分，最终由子数组形成整个排序好的数组

<a data-fancybox title="快速排序" href="/计算机通用/quick_sort.png">![快速排序](/计算机通用/quick_sort.png)</a>

```js
function quickSort(arr) {
  sort(arr, 0, arr.length - 1);
  return arr;
}

function sort(arr, low, high) {
  if (low > high) return;
  let i = low;
  let j = high;
  let base = arr[low];
  while (i < j) {
        // 左边开始扫描
    while (arr[i] <= base && i < j) {
      i++;
    }
    // 右边开始扫描
    while (arr[j] >= base && i < j) {
      j--;
    }
    exeh(arr, i, j);
  }
  //最后将基准为与i和j相等位置的数字交换
  exeh(arr, low, i);
  //递归调用左半数组
  sort(arr, low, j - 1);
  //递归调用右半数组
  sort(arr, j + 1, high);
}

function exch(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
```
