## 概述

双指针是指在遍历对象（有序数组）时，通过相同方向（快慢指针）或者相反方向（对撞指针）进行扫描，从而取到相应的结果。

### 快慢指针

利用快的指针对后续内容进行扫描来和慢指针比较，得到预期结果

> https://leetcode-cn.com/problems/subarray-product-less-than-k/

给定一个正整数数组 nums 和整数 k 。

请找出该数组内乘积小于 k 的连续的子数组的个数。

输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function(nums, k) {
  if (k === 0) return 0;
  let sum = 0;
  let product = 1;
  let left = 0;
  let numsLen = nums.length;
  for (let right = 0; right < numsLen; right++) {
    // 符合预期数组的乘积
    product *= nums[right];
    // 一旦乘积大于指定，就左边的指针往右移
    while (product >= k && left <= right) {
      product /= nums[left];
      left++;
    }
    // [2,4,1,3] => [[2,4,1,3], [4,1,3], [1,3], [3]]
    sum += right - left + 1;
  }
  return sum;
};
```

### 对撞指针

low --> expect <-- high

【**例题 1**】给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  if (!nums || !nums.length || nums.length === 1) return [];
  let result = [];
  let low = 0;
  let high = nums.length - 1;
  nums.sort((a, b) => a - b);
  for (i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let target = -nums[i];
    low = i + 1;
    high = nums.length - 1;
    while (low < high) {
      if (nums[low] + nums[high] > target) {
        --high;
      } else if (nums[low] + nums[high] < target) {
        ++low;
      } else {
        result.push([nums[i], nums[low], nums[high]]);
        while (low < high && nums[low] === nums[++low]);
        while (low < high && nums[high] === nums[--high]);
      }
    }
  }
  return result;
};
```

## 实战

> 转：leetcode： https://leetcode-cn.com/problems/backspace-string-compare/

给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var backspaceCompare = function(s, t) {
  if (s === t) return true;
  let i = s.length - 1;
  let j = t.length - 1;
  let spaceS = 0;
  let spaceT = 0;
  // 由于#只能删除前面的，不能删除后面的，所以比较当右边没有#时所留下来的字符
  while (i >= 0 || j >= 0) {
    // 指针从右到左
    while (i >= 0) {
      if (s[i] === '#') {
        ++spaceS;
        --i;
      } else if (spaceS > 0) {
        --spaceS;
        --i;
      } else {
        break;
      }
    }
    while (j >= 0) {
      if (t[j] === '#') {
        ++spaceT;
        --j;
      } else if (spaceT > 0) {
        --spaceT;
        --j;
      } else {
        break;
      }
    }
    if (s[i] !== t[j]) return false;
    --i;
    --j;
  }
  return true;
};
```
