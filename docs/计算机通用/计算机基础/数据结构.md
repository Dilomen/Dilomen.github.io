---
title: 数据结构
tags: 数据结构
categories: 计算机基础
keywords: 数据结构,计算机基础
description: 数据结构
date: 2019-08-19 22:15:09
---

:::tip
由于本人主要学习的是 JS，所以主要以 JS 的角度思考
:::

## 线性结构

### 数组

数组是在内存中连续分配存储的线性结构，可以使用数组的索引进行访问，从 0 开始

**优点：**  
查找和修改指定索引内容速度快  
**缺点：**  
添加，删除操作比较慢，需要移动别的元素

```js
let arr = [1, 2, 3];
// 查：arr[0];
// 增：push, unshift等;
// 删：pop, shift等;
// 改：replace等;
```

### 栈

栈是一种后进先出(LIFO)的线性结构

- 只允许在端进行操作，插入数据的一端叫做**栈顶**，删除数据的一端称为**栈底**
- 向栈中添加数据称为**压栈**或者**入栈**，删除数据称为**出栈**

#### 实现

- 基于数组

```js
class Stack {
  constructor() {
    this.items = [];
  }
  // 压栈
  push(item) {
    this.items.push(item);
  }
  // 出栈
  pop(item) {
    return this.items.pop();
  }
  // 查看栈顶元素
  peek() {
    return this.items[this.items.length - 1];
  }
  // 查看栈是否为空
  isEmpty() {
    return this.items.length === 0;
  }
  // 查看栈的元素个数
  size() {
    return this.items.length;
  }
  // 输出栈的内容
  toString() {
    return this.items.join(',').replace(/,/g, ' ');
  }
}

let stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
stack.pop();
console.log(stack.size());
```

#### 函数调用栈

如果 A 函数调用了 B 函数，B 函数调用了 C 函数，那么 JS 执行就会现将 A 先压入栈，然后将 B 压入栈，最后将 C 压入栈，执行时，C 先被执行完成出栈，再 B 出栈,最后 A 出栈

### 队列

队列是一种先进先出的(FIFO)的线性结构

#### 实现

- 基于数组

```js
class Queue {
  constructor() {
    this.items = [];
  }
  static getInstance() {
    if (!this.items) {
      this.items = new Queue();
    }
    return this.items;
  }

  // 添加队列元素
  enqueue(item) {
    this.items.push(item);
  }
  // 删除队列前端元素
  dequeue(item) {
    return this.items.shift();
  }
  // 查看队列前端元素
  front() {
    return this.items[this.items.length - 1];
  }
  // 查看队列是否为空
  isEmpty() {
    return this.items.length === 0;
  }
  // 查看队列的元素个数
  size() {
    return this.items.length;
  }
  // 输出栈的内容
  toString() {
    return this.items.join(',').replace(/,/g, ' ');
  }
}

let queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
queue.dequeue();
console.log(queue.size());
```

#### 优先级队列

```js
function QueueElement(element, priority) {
  this.element = element;
  this.priority = priority;
}

function priorityQueue() {
  this.items = [];
}
priorityQueue.prototype.enqueue = function (element, priority) {
  let queueElement = new QueueElement(element, priority);
  if (this.items.length === 0) {
    this.items.push(queueElement);
  } else {
    for (let i = 0; i < this.items.length; i++) {
      if (this.items[i].priority > queueElement.priority) {
        this.items.splice(i, 0, queueElement);
        return;
      }
    }
  }
};

priorityQueue.prototype.toString = function () {
  let resultString = '';
  for (let i = 0; i < this.items.length; i++) {
    resultString += `${this.items[i].element}-${this.items[i].priority} `;
  }
  return resultString;
};
其余和基本队列一致;
```

### 链表

链表和数组一样也是存储一系列元素的线性结构，存储不需要连续的空间，每个元素是由一个存储元素本身的节点和一个指向下一个元素的引用

#### 常见操作

- append:向链表尾部添加一个新的项
- insert:向链表特定的位置插入一个新的项
- get:获取对应位置的项
- indexOf:返回元素在链表中的索引，如果不存在就返回-1
- update:修改某个位置的元素
- removeAt:从链表特定位置移除一项
- remove:从链表中移除一项
- isEmpty:链表是否为空
- size:返回链表的元素个数
- toString:输出链表字符串

**优点：**  
插入，删除元素速度快  
存储不需要连续的空间（是否优点取决于处理场景）
**缺点：**  
查找比较慢，每次需要从第一个开始找

#### 实现

```js
function Node(data) {
  this.data = data;
  this.next = null;
}

function SingleList() {
  this.head = null;
  this.length = 0;
}

SingleList.prototype.append = function (data) {
  // 创建新的节点
  let newNode = new Node(data);
  // 判断添加的是否是第一个节点
  if (this.length === 0) {
    this.head = newNode;
  } else {
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    // 最后一个节点的next指向新的节点
    current.next = newNode;
  }
  // 链表长度加1
  this.length += 1;
};

SingleList.prototype.insert = function (position, data) {
  if (position < 0 || position > this.length) return false;
  let newNode = new Node(data);
  // 如果链表为空，直接让头节点指向该节点
  if (this.length === 0) {
    this.head = newNode;
  } else {
    let current = this.head;
    while (--position) {
      current = current.next;
    }
    newNode.next = current.next;
    current.next = newNode;
  }
  this.length += 1;
};

SingleList.prototype.get = function (position) {
  if (position < 0 || position >= this.length) return false;
  let current = this.head;
  while (position--) {
    current = current.next;
  }
  return current.data;
};

SingleList.prototype.indexOf = function (data) {
  let current = this.head;
  let index = 0;
  while (current) {
    if (data === current.data) return index;
    current = current.next;
    index++;
  }
  return -1;
};

SingleList.prototype.update = function (position, newData) {
  if (position < 0 || position >= this.length) return false;
  let current = this.head;
  while (position--) {
    current = current.next;
  }
  current.data = newData;
};

SingleList.prototype.removeAt = function (position) {
  if (position < 0 || position >= this.length) return false;
  let current = this.head;
  // 如果删除的是第一个节点
  if (position === 0) {
    this.head = this.head.next;
  } else {
    let prevNode = null;
    // 如果不是第一个节点
    while (position--) {
      prevNode = current;
      // 取到被移除节点的前一个节点
      current = current.next;
    }
    prevNode.next = current.next;
  }
  this.length -= 1;
  return current.data;
};

SingleList.prototype.remove = function (data) {
  let index = this.indexOf(data);
  return this.removeAt(index);
};

SingleList.prototype.isEmpty = function (data) {
  return this.lenght === 0;
};

SingleList.prototype.size = function (data) {
  return this.lenght;
};

SingleList.prototype.toString = function () {
  let current = this.head;
  let listString = '';
  while (current) {
    listString += current.data + ' ';
    current = current.next;
  }
  return listString;
};

let singleList = new SingleList();
singleList.append('111');
singleList.append('222');
singleList.insert(1, '1');
singleList.append('333333');
singleList.insert(3, '3');
singleList.update(0, '3111');
console.log(singleList.remove('1'));
console.log(singleList.toString(), singleList.length);
```

### 双向链表

双向链表一个节点包含前元素本身和一个节点的引用，后一个节点引用所连接的链表，有效的解决了单向链表每次都需要从 head 开始的问题

<a data-fancybox title="双向链表" href="/计算机通用/双向链表.png">![双向链表](/计算机通用/双向链表.png)</a>

#### 实现

```js
function Node(data) {
  this.data = data;
  this.prev = null;
  this.next = null;
}
function DoubleList() {
  this.length = 0;
  this.head = null;
  this.tail = null;
}

DoubleList.prototype.append = function (data) {
  let newNode = new Node(data);
  if (this.length === 0) {
    this.head = newNode;
    this.tail = newNode;
  } else {
    // 将新的节点的前引用指向尾节点，尾节点的后引用指向新的节点
    newNode.prev = this.tail;
    this.tail.next = newNode;
    // 尾节点变为新的节点
    this.tail = newNode;
  }
  this.length += 1;
};
DoubleList.prototype.insert = function (position, data) {
  if (position < 0 || position > this.length)
    throw new Error('插入的索引不得超出范围（0 < position < length）');
  let newNode = new Node(data);
  // 如果链表为空，直接将头尾指向新的节点
  if (this.length === 0) {
    this.head = newNode;
    this.tail = newNode;
  } else {
    // 如果插入的是头部，那么赋给头节点
    if (position === 0) {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
      // 如果插入的是尾部，那么调用
    } else if (position === this.length) {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    } else {
      let current = this.head;
      let prevNode = null;
      while (position--) {
        prevNode = current;
        current = current.next;
      }
      prevNode.next = newNode;
      newNode.prev = prevNode;
      newNode.next = current;
      current.prev = newNode;
    }
  }
  this.length += 1;
};
DoubleList.prototype.get = function (position) {
  if (position < 0 || position >= this.length)
    throw new Error('查询的索引不得超出范围（0 < position < length）');
  let current = null;
  // 如果索引大于一半，就从后面开始找，否则就从前面开始找
  if (position < this.length / 2) {
    current = this.head;
    while (position--) {
      current = current.next;
    }
  } else {
    current = this.tail;
    position = this.length - position - 1;
    while (position--) {
      current = current.prev;
    }
  }

  return current.data;
};

DoubleList.prototype.indexOf = function (data) {
  let current = this.head;
  let index = 0;
  while (current) {
    if (current.data === data) return index;
    current = current.next;
    index++;
  }
  return -1;
};

DoubleList.prototype.update = function (position, newData) {
  if (position < 0 || position >= this.length)
    throw new Error('更新的索引不得超出范围（0 < position < length）');
  let current = null;
  if (position < this.length / 2) {
    current = this.head;
    while (position--) {
      current = current.next;
    }
  } else {
    current = this.tail;
    position = this.length - position - 1;
    while (position--) {
      current = current.prev;
    }
  }

  current.data = newData;
  return -1;
};

DoubleList.prototype.removeAt = function (position) {
  if (position < 0 || position >= this.length)
    throw new Error('删除的索引不得超出范围（0 < position < length）');
  let current;
  // 如果链表只有一个元素
  if (this.length === 1) {
    current = this.head;
    this.head = null;
    this.tail = null;
  } else {
    // 如果删除的是最后一个
    if (position === this.length - 1) {
      let current = this.tail;
      this.tail = this.tail.prev;
      this.tail.next = null;
      return current.data;
    }
    // 如果索引小于一半，从前遍历，大于一半，从后遍历
    if (position < this.length / 2) {
      if (position === 0) {
        this.head = this.head.next;
      }
      current = this.head;
      while (position--) {
        current = current.next;
      }
    } else {
      current = this.tail;
      position = this.length - position - 1;
      while (position--) {
        current = current.prev;
      }
    }
    current.next.prev = current.prev;
    current.prev.next = current.next;
  }
  this.length -= 1;
  return current.data;
};

DoubleList.prototype.remove = function (data) {
  let index = this.indexOf(data);
  return this.removeAt(index);
};

// 向前遍历
DoubleList.prototype.forwardString = function () {
  let current = this.tail;
  let resultString = '';
  while (current) {
    resultString = resultString + current.data + ' ';
    current = current.prev;
  }
  return resultString;
};
// 向后遍历
DoubleList.prototype.backwardString = function () {
  let current = this.head;
  let resultString = '';
  while (current) {
    resultString = resultString + current.data + ' ';
    current = current.next;
  }
  return resultString;
};
DoubleList.prototype.isEmpty = function () {
  return this.length === 0;
};
DoubleList.prototype.size = function () {
  return this.length;
};
let doubleList = new DoubleList();
doubleList.append('1');
doubleList.append('2');
doubleList.append('3');
doubleList.insert(2, '111');
doubleList.update(1, 'dd');
console.log(doubleList.indexOf('2'));
console.log(doubleList.remove('1'));
console.log(doubleList.get(1));
console.log(doubleList.backwardString(), doubleList.size());
```

## 非线性结构

### 集合

集合是一个没有顺序且不重复的存储结构，比如 ES6 中的 Set

#### 实现

```js
function Set() {
  this.items = {};
}
Set.prototype.add = function (value) {
  if (this.has(value)) return false;
  this.items[value] = value;
  return true;
};
Set.prototype.has = function (value) {
  return this.items.hasOwnProperty(value);
};
Set.prototype.remove = function (value) {
  if (!this.has(value)) return false;
  delete this.items[value];
  return true;
};
Set.prototype.clear = function () {
  this.items = {};
};
Set.prototype.size = function () {
  return Object.keys(this.items).length;
};
Set.prototype.values = function () {
  return Object.keys(this.items);
};
```

#### 集合间的操作

1. 并集（包含 A，B）

```js
Set.prototype.union = function (otherSet) {
  let unionSet = new Set();
  let values = this.values();
  values.forEach((value) => unionSet.add(values[i]));
  otherValues = otherSet.values();
  otherValues.forEach((value) => unionSet.add(values[i]));
  return unionSet;
};
```

2. 交集（既存在于 A 又存在于 B）

```js
Set.prototype.intersection = function (otherSet) {
  let intersection = new Set();
  let values = this.values();
  values.forEach((value) => {
    if (otherSet.has(value)) {
      intersection.add(value);
    }
  });
  return intersection;
};
```

3. 差集 （存在于 A，不存在于 B）

```js
Set.prototype.difference = function (otherSet) {
  let difference = new Set();
  let values = this.values();
  values.forEach((value) => {
    if (!otherSet.has(value)) {
      difference.add(value);
    }
  });
  return difference;
};
```

4. 子集 （A 是否是 B 的一个子集）

```js
Set.prototype.subset = function (otherSet) {
  let values = this.values();
  for (let i = 0; i < values.length; i++) {
    if (!otherSet.has(values[i])) {
      return false;
    }
  }
  return true;
};
```

### 字典

字典是一种键值对的存储结构，可以通过 key 来获取 value，但是 key 不能有重复，比如 ES6 中的 Map
:::tip
字典和对象和相似，但是对象在静态语言中是不可添加和删除属性的，而字典则可以
:::

```js
function Map() {
  this.items = {};
}
Map.prototype.set = function(key, value) {
  if (this.has(key)) return false;
  this.items[key] = value;
  return true;
};
Map.prototype.get = function(key) {
  return this.items[key];
};
Map.prototype.delete = function(key) {
  if (!this.has(key)) return false;
  delete this.items[key];
  return true;
};
Map.prototype.has = function(key) {
  return this.items.hasOwnProperty(key);
};
Map.prototype.keys = function(key) {
  let keyString = '';
  this.items.forEach(key => keyString += `${key} `);
  return keyString;
};
...
```

### 哈希表（散列表）

哈希表是一个键值对，可以通过关键码 key 值来映射到表中的地址来访问记录

**优点：**  
速度非常的快，插入和查找操作的时间复杂度都是 O(1)  
**缺点：**  
当数据很多时，可能会出现冲突，解决方案复杂度最差会达到 O(n)
哈希表的数据是没有排序的

#### 哈希化

将大数字转化成数组范围内下标的过程，称之为哈希化

#### 哈希函数

将单词转化为大数字，大数字进行哈希化的代码实现的函数

#### 哈希表

将数据插入到这个数组，形成哈希表

#### 如题

已知一个线性表（38，25，74，63，52，48），假定采用散列函数 h(key)=key%7 计算散列地址，并散列存储在散列表 A[0,...,6]中

<a data-fancybox title="散列表例题1" href="/计算机通用/散列表例题1.png">![散列表例题1](/计算机通用/散列表例题1.png)</a>

#### 哈希冲突

当数据量大的时候，就会出现哈希冲突的可能

- **解决方案**
  - **_链地址法解析_**：即在每个存储单位存储一个链表（推荐）或者一个数组，将冲突后数据依次排在当前存储单位现有数据后面
  - **_开放地址法_**：寻找空的存储单位来存储新的数据
    - 线性探测
    - 二次探测
    - 再哈希法

#### 实现

```js
function HashTable() {
  // 存放的元素
  this.storage = [];
  // 存放的元素数量
  this.count = 0;
  // 限制的长度，最好是质数
  this.limit = 7;
}
HashTable.prototype.hashFunc = function (str, size) {
  // 定义hashCode变量
  let hashCode = 0;
  for (let i = 0; i < str.length; i++) {
    hashCode = 37 * hashCode + str.charCodeAt(i);
  }
  let index = hashCode % size;
  return index;
};
HashTable.prototype.put = function (key, value) {
  // 根据key获取对应的index
  let index = this.hashFunc(key, this.limit);
  let bucket = this.storage[index];
  if (!bucket) {
    bucket = [];
    this.storage[index] = bucket;
  }
  // 修改
  let length = bucket.length;
  for (let i = 0; i < length; i++) {
    let tuple = bucket[i];
    if (tuple[0] === key) {
      tuple[1] = value;
      return;
    }
  }
  // 新增
  bucket.push([key, value]);
  this.count += 1;
};
HashTable.prototype.get = function (key) {
  let index = this.hashFunc(key, this.limit);
  let bucket = this.storage[index];
  if (!bucket) return -1;
  let length = bucket.length;
  for (let i = 0; i < length; i++) {
    let tuple = bucket[i];
    if (tuple[0] === key) {
      return tuple[1];
    }
    return -1;
  }
};
HashTable.prototype.remove = function (key) {
  let index = this.hashFunc(key, this.limit);
  let bucket = this.storage[index];
  if (!bucket) return false;
  for (let i = 0; i < bucket.length; i++) {
    let tuple = bucket[i];
    if (tuple[0] === key) {
      bucket.splice(i, 1);
      this.count -= 1;
      return tuple[1];
    }
  }
  return false;
};

HashTable.prototype.isEmpty = function () {
  return this.count === 0;
};

HashTable.prototype.size = function () {
  return this.count;
};
```

#### 哈希表扩容

虽然哈希表可以无限制的插入新数据，但是过长的单链会导致效率变低，此时就需要扩容 1 倍，一般在占比大于 75%需要扩容

```js
function
HashTable.prototype.put = function(key, value) {
  ...
  // 判断是否需要扩容
  if (this.count / this.limit > 0.75) {
    let newPrime = this.getPrime(this.limit * 2);
    this.resize(newPrime);
  }
};
HashTable.prototype.resize = function(newLimit) {
  // 保存旧的数据内容
  var oldStorage = this.storage;
  // 重置所有的数据
  this.storage = [];
  this.count = 0;
  this.limit = newLimit;
  // 遍历老数据,加入到新的哈希表
  for (let i = 0; i < oldStorage; i++) {
    let bucket = oldStorage[i];
    if (!bucket) continue;
    for (let j = 0; j < bucket.length; j++) {
      let tuple = bucket[j];
      this.put(tuple[0], tuple[1]);
    }
  }
};

// 判断是否为质数
function isPrime(data) {
  let sqrt = parseInt(Math.sqrt(data));
  for (let i = 0; i < sqrt; i++) {
    if (data % i === 0) {
      return false;
    }
  }
  return true;
}
// 获取质数
HashTable.prototype.getPrime= function(newSize) {
  while (!isPrime(newSize)) {
    newSize++;
  }
  return newSize;
}
```

### 树
