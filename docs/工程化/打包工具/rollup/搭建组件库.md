> 项目地址： [https://github.com/Dilomen/serein-ui](https://github.com/Dilomen/serein-ui)

## why use

首先 rollup 相比较 webpack，可能生态没有那么丰富，但是它依旧满足我们的组件库需求，而且其配置更加简单，打包容量也是更加轻巧，而且对打包出 es 模块有天生的配置。

## 需求

组件库要满足对所有代码的总体打包和对各个组件的打包（主要是 ESModule 下），用以按需加载，以及打包 umd，iife，cjs 等不同模块机制。

## 解决办法

将整个组件导出文件 index.js 和每个组件的导出分别作为 rollup 的 import 入口，分别导出对应的文件。

## 配置

为了结构更加清晰和减少对应环境下不必要的执行，提升打包效率，可以将配置文件分为

```md
|- config
|-- rollup.common.js 共有部分
|-- rollup.dev.js 开发环境配置
|-- rollup.prod.js 生产环境配置
```

#### 共有部分

共有的 plugin

```js
// 将json转化为es模块
const json = require("rollup-plugin-json");
// rollup-plugin-node-resolve 插件可以告诉 Rollup 如何查找外部模块
const resolve = require("rollup-plugin-node-resolve");
// 将 CommonJS 模块转换为 ES2015 供 Rollup 处理
const commonjs = require("rollup-plugin-commonjs");
// 使用babel
const babel = require("rollup-plugin-babel");
// 使用typescript
const typescript = require("rollup-plugin-typescript2");
// 当前环境
const ENV = process.env.NODE_ENV;
// 编译css
const postcss = require("rollup-plugin-postcss");
const autoprefixer = require("autoprefixer");
const cssnano = require("cssnano");
// 变量替换，可以将动态设置的变量提取出来在配置文件中设置
const replace = require("rollup-plugin-replace");
// 清除文件
const clear = require("rollup-plugin-clear");
const commonPlugin = [
  resolve({
    jsnext: true,
    main: true,
    browser: true,
  }),
  typescript({
    clean: true,
    tsconfigOverride: {
      compilerOptions: {
        module: "ESNext",
      },
    },
  }),
  commonjs(),
  babel({
    runtimeHelpers: true,
    exclude: "node_modules/**",
    extensions: [".ts", ".tsx", "js", "jsx"],
  }),
  json(),
  replace({
    "process.env.NODE_ENV": JSON.stringify(ENV),
  }),
];
```

#### 开发环境

开发环境对入口文件进行修改，以及添加支持预览的一些 plugin

```js
//开启服务插件
const serve = require("rollup-plugin-serve");
// 监听文件改变，并刷新浏览器
const livereload = require("rollup-plugin-livereload");
plugins: [
    postcss({
        extract: `./build/index.css`,
        extensions: [".css", ".scss"],
        plugins: [autoprefixer, cssnano],
    }),
    ...commonPlugin,
    serve({
        open: true, // 是否打开浏览器
        contentBase: "./", // 入口html的文件位置
        historyApiFallback: true, // Set to true to return index.html instead of 404
        host: "localhost",
        port: 8002,
    }),
    livereload(),
],
watch: {
    include: "src/**",
    clearScreen: true,
}
```

#### 生产环境

将所有的 components 下的组件文件夹通过 node 遍历，获取到各个组件名，然后各个打包

```js
const cModuleNames = fs.readdirSync(path.resolve(componentDir));
const cModuleMap = cModuleNames.reduce((arr, dirname) => {
  // 防止mac下生成的.DS_Store目录
  if (dirname !== ".DS_Store") {
    arr[dirname] = `${componentDir}/${dirname}/index.ts`;
  }
  return arr;
}, {});
// 然后就可以对各个组件进行单独打包
{
    input: { ...cModuleMap },
    output: {
      format: "esm",
      dir: "es", // 输出到一个目录而不是一个文件
      entryFileNames: "[name]/index.js", // 输出文件名
      minify: true,
      // sourcemap: true,
      exports: "named",
    },
}
```

js 可以多文件导入，但是 css 需要分多个配置了，rollup 配置支持数组的形式执行多个配置

```js
// 将css读写到对应的打包文件夹下
const createStyle = (cModuleName, path) => ({
  input: { [cModuleName]: path },
  // 没意义，但是由于rollup必须写output，所以还是写一个吧
  output: {
    dir: `noNeed/${cModuleName}/index.js`,
    format: "esm",
  },
  plugins: [
    clear({ targets: ["noNeed"] }),
    postcss({
      extract: `./es/${cModuleName}/index.css`,
      extensions: [".css", ".scss"],
      plugins: [autoprefixer, cssnano],
    }),
    ...commonPlugin,
  ],
});

let CSSGroup = {};
Object.keys(cModuleMap).map(
  (cModuleName) =>
    (CSSGroup[cModuleName] = createStyle(cModuleName, cModuleMap[cModuleName]))
);
```

这样就完成了对所有组件的整体打包和个体打包。最后将打包的文件夹上传至 npm。

## 按需加载

既然对各个组件都进行了单独了打包，那么按需加载必须也要跟上。

#### 原理

将你从总文件导入的组件，详细到具体组件中导入，减少不必要的引入

```js
import { Button } from "xx-ui";
// 细分到对应组件，可能还要再导入样式
import Button from "xx-ui/Button/index.js";
import "xx-ui/Button/index.css";
```

#### 实现

自定义一个 babel 的 plugin 插件，在 AST 上对导入进行更改

可参考 antd 的[babel-plugin-import](https://github.com/ant-design/babel-plugin-import/blob/master/src/Plugin.js#L36)

[babel 插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin)

```js
// babel插件规范
export default function({ types: t }) {
  return {
    visitor: {
      // visitor contents
      // 可以使用个周钩子函数来处理对应AST中的内容
    },
  };
}
```

```js
// @babel/helper-module-imports插件babel是对导入module进行操作的工具插件
var healperImport = require("@babel/helper-module-imports");

class ImportPlugin {
  constructor(libraryName, libraryDirectory) {
    this.libraryName = libraryName;
    this.libraryDirectory = libraryDirectory;
    this.libraryPath = `${libraryName}/${libraryDirectory}`;
    this.willImportMap = {};
    this.importedMap = {};
  }
  getWillImportMap(key) {
    return this.willImportMap[key];
  }
  setWillImportMap(key, value) {
    this.willImportMap[key] = value;
  }
  getImportedMap(key) {
    return this.importedMap[key];
  }
  setImportedMap(key, value) {
    this.importedMap[key] = value;
  }
  importMethod(path, file) {
    for (let prop in this.willImportMap) {
      if (this.getWillImportMap(prop)) {
        let importPath = `${this.libraryPath}/${prop}`;
        // addDefault(path, 资源路径, { nameHint: "组件名" }) -> import 组件名 from "资源路径"
        let imported = healperImport.addDefault(
          file.path,
          `${importPath}/index.js`,
          { nameHint: prop }
        );
        // addSideEffect(path, 资源路径) -> import "资源路径"
        healperImport.addSideEffect(file.path, `${importPath}/index.css`);
        this.setImportedMap(prop, imported);
        return imported;
      }
    }
  }
}

let importPlugin = null;
module.exports = function({ types }) {
  return {
    visitor: {
      // Program钩子函数主要接收webpack的配置
      Program: {
        enter(path, { opts = {} }) {
          importPlugin = new ImportPlugin(
            opts.libraryName,
            opts.libraryDirectory
          );
          console.log(importPlugin)
        },
      },
      // ImportDeclaration钩子函数主要处理import之类的源码
      ImportDeclaration: {
        enter(path, state) {
          const {
            node,
            hub: { file },
          } = path;
          if (!node) return;
          // value 导入模块的来源（String） specifiers 引入的模块（Node） {Button, Text} -> [Node {...Button}, Node {...Text}]
          const { source: { value } = {}, specifiers = [] } = node;
          if (value === importPlugin.libraryName) {
            specifiers.forEach((spec) => {
              importPlugin.setWillImportMap(spec.local.name, spec.local.name);
            });
            // 移除原先的模块导入
            path.remove();
            // 添加新的模块导入
            importPlugin.importMethod(path, file);
          }
        },
      },
      // 所有的标识符
      Identifier(path) {
        let value = importPlugin.getImportedMap(path.node.name);
        // hasOwnProperty主要是防止对象下的原生属性，如__proto__默认值为{}
        if (value && importPlugin.importedMap.hasOwnProperty(path.node.name)) {
          // 替换代码中的组件引用
          path.replaceWith(value);
        }
      },
    },
  };
};
```
