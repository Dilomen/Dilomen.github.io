## 查询

testing-library 提供了一些查询方法方便定位到具体的元素，以便于测试
[官方文档地址](https://testing-library.com/docs/queries/about)

```js
// demo
import { render, screen } from "@testing-library/react";

test("should show login form", () => {
  render(<Button>确定</Button>);
  const btn = screen.getByText("确定");
});
```

主要有三个类型 get，query，find。

- 查询单个的 API:getBy，queryBy，findBy
- 查询多个的 API:getAllBy，queryAllBy，findAllBy

查询单个的 API 如果匹配到多个都会报错，所以一般都是用于精准定位元素的

| 类型  | 是否异步 | 未匹配是否报错 |
| ----- | -------- | -------------- |
| get   | 同步     | 报错           |
| query | 同步     | 返回 null      |
| find  | 异步     | 报错           |

## screen

优先使用 screen 下的查询 API，不然的话，就必须将 container 作为第一个元素传给查询 API

```js
const { getByText, container } = render(<Button>确定</Button>);
const btn = getByText(container, "确定");

const { screen } = render(<Button>确定</Button>);
const btn = screen.getByText("确定");
```

## 支持匹配

查询 API 可以支持字符串，模糊匹配（如忽略大小写，子串匹配），正则，方法

```js
screen.getByText("Hello World");
// 忽略大小写
screen.getByText("hello world", { extra: false });
// 子串匹配
screen.getByText("orld", { extra: false });
// 正则
screen.getByText(/World$/);
// 方法
screen.getByText((content, element) => content.startsWith("Hello"));
```

## example

建议使用优先级

getByRole => getByLabelText => getByPlaceholderText => getByText => getByDisplayValue => getByAltText => getByTitle => getByTestId

### getByRole

```js
render(<label role="UserName" />);
screen.getByRole("UserName");
```

### getByLabelText

```js
render(
  <label>
    Hello <input value="value" />
  </label>
);
screen.getByLabelText("Hello"); // <input value="value" />
```

### getByDisplayValue

```js
render(<input value="aaa" />);
screen.getByDisplayValue("aaa");
```

### getByTestId

```js
data - testid = "bbb";
render(<div data-testid="bbb" />);
screen.getByTestId("bbb");
```

## 异步处理

由于 find 相关的都是异步查询，所以就要使用对应的异步方式

### await

```js
test("movie title appears", async () => {
  const text = await findByText("The text");
});
```

### waitFor

采用的是定时查询（轮询）的方式

```js
test('movie title appears', async () => {
  // do something
  await waitFor(() => {
    expect(getByText('The text')).toBeInTheDocument()
  }
})
```

### waitForElementToBeRemoved

基于 HTML 的 MutationObserver API，监听元素的变化，一旦变化才出发，因此性能比 waitFor 更高

```js
test("Test text", async () => {
  // element is removed
  await waitForElementToBeRemoved(() => queryByText("The text"));
});
```

## 关于查询断言

首先getBy和queryBy在没有找到对应的元素的话，都会报错，但是queryBy可以被断言

```js
// queryBy可以断言是否为null
expect(screen.queryByText('addBtn')).not.toBeNull();
// 如果是多个，由于会返回数组，所以判断数组长度是否为0
expect(screen.queryAllByText('btn')).not.toHaveLength(0);
```

还有一种就是使用jest-dom提供的辅助方法，当然你也可以编写你自定义的方法来满足这种场景

```js
import '@testing-library/jest-dom/extend-expect'

expect(screen.queryByText('addBtn')).not.toBeInTheDocument()
```