## 概述

Jest 是由 Facebook 基于 Jasmine 框架改写的一款“开箱即用”的单测框架，其支持断言，仿真（mock），异步，快照等等，功能非常强大，也是 React 和 Vue 官方最为推荐的单元测试框架（Angular 默认的单测框架是 Karma + Jasmine）。

## 断言

首先我们知道单测，就是我们输入一个结果，然后测试输出的内容是否是我们期望的，那么这个比较，就是由断言功能来完成的

[完整 API](https://jestjs.io/zh-Hans/docs/expect)

#### 基本类型和引用类型比较，基本的值等于或者不等于

```js
// 精准比较
expect(1 + 2).toBe(3);
// 引用类型的比较
expect({ a: 1 }).toEqual({ b: 1 });
// 只匹配null
expect(null).toBeNull();
// 只匹配null
expect(undefined).toBeUndefined();
// 真
expect(true).toBeTruthy();
// 假
expect(false).toBeFalsy();
// not 取反
expect(undefined).not.toBeFalsy();
// NaN
expect(NaN).toBeNaN();
```

#### 数字比较，主要是大于小于等特殊的比较方式

```js
// 大于
expect(2 + 2).toBeGreaterThan(3);
// 大于等于
expect(2 + 2).toBeGreaterOrEqualThan(4);
// 小于
expect(1 + 1).toBeGreaterThan(3);
// 小于等于
expect(1 + 2).toBeGreaterOrEqualThan(3);
// 由于js精度问题，所以对于浮点数要使用toBeCloseTo
expect(0.1 + 0.2).toBeCloseTo(0.3);
```

#### 字符串比较，可以使用进行正则匹配

```js
expect("abcdefg").toMatch(/abc/);
expect("abcdefg").not.toMatch(/poiu/);
```

#### 查找数组或可迭代对象是否有指定项

```js
expect([1, 2, 3, 4]).toContain(1);
expect(new Set([1, 2, 3, 4])).toContain(1);
// 递归深度比较
expect([1, 2, { a: { b: 2 } }, 4]).toContainEqual({ a: { b: 1 } });
```

#### 检测是否是某个类的实例

```js
expect(new Person()).toBeInstanceOf(Person);
```

#### 是否报错

```js
expect(fn()).toThrow();
```

#### 快照和 mock 相关的会放在对应模块

#### 自定义

expect.extend 直接声明对应的方法，方法接受的参数为 expect 的参数，加上自身的参数

```js
expect(a).toFn(b, c, d) ===> expect.extend({ toFn(a,b,c,d) })
```

```js
// 小于10
expect(1 + 2).toLessTen();

expect.extend({
  toLessTen(recevied) {
    const pass = recevied < 10;
    return {
      pass,
      message: () => (pass ? "success" : "fail"),
    };
  },
});
```

## 异步处理

异步是 JS 常见的一个操作，但是 Jest 无法知道其什么时候结束才能跳转到下一个测试中去，因此需要告知 Jest，什么时候结束，它才能测到对应的内容

#### 调用 done 方法

在异步执行完成的时候使用 done 方法

```js
test("Test Async Function", (done) => {
  promise().then(() => {
    // do something
    done();
  });
});
```

#### 返回 promise

```js
test("Test Async Function", () => {
  return promise().then(() => {
    // do something
  });
});
```

#### 使用期望方法

.resolves / .rejects

```js
test("Test Async Function", () => {
  expect(promise())
    .resolves()
    .toBe();

  expect(promise())
    .rejects()
    .toBe();
});
```

#### async/await

```js
test("Test Async Function", async () => {
  await promise();
  // do something
});
```

#### 优先使用 async/await，其次是 done，因为这两者跟我们平时开发写 JS 的习惯更为接近，返回 promise 的写法容易忘记 return，使用期望则需要额外的成本，没有必要

## mock

很熟悉的名词吧，但是一般我们认为的 mock 就是模拟接口，是的，正如其含义“模拟的”，那么在 Jest 里，它也是模拟各种方法以供调用，包括模拟接口

## 快照

## 待续