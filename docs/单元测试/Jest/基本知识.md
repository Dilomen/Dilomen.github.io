## 概述

Jest 是由 Facebook 基于 Jasmine 框架（后面会重写，全部替换掉）改写的一款“开箱即用”的单测框架，其支持断言，仿真（mock），异步，快照，JSDOM等等，功能非常强大，也是 React 和 Vue 官方最为推荐的单元测试框架（Angular 默认的单测框架是 Karma + Jasmine）。

## 断言

首先我们知道单测，就是我们输入一个结果，然后测试输出的内容是否是我们期望的，那么这个比较，就是由断言功能来完成的

[完整 API](https://jestjs.io/zh-Hans/docs/expect)

#### 基本类型和引用类型比较，基本就是等于或者不等于

```js
// 精准比较
expect(1 + 2).toBe(3);
// 引用类型的比较
expect({ a: 1 }).toEqual({ b: 1 });
// 只匹配null
expect(null).toBeNull();
// 只匹配null
expect(undefined).toBeUndefined();
// 真
expect(true).toBeTruthy();
// 假
expect(false).toBeFalsy();
// not 取反
expect(undefined).not.toBeFalsy();
// NaN
expect(NaN).toBeNaN();
```

#### 数字比较，主要是大于小于等特殊的比较方式

```js
// 大于
expect(2 + 2).toBeGreaterThan(3);
// 大于等于
expect(2 + 2).toBeGreaterOrEqualThan(4);
// 小于
expect(1 + 1).toBeGreaterThan(3);
// 小于等于
expect(1 + 2).toBeGreaterOrEqualThan(3);
// 由于js精度问题，所以对于浮点数要使用toBeCloseTo
expect(0.1 + 0.2).toBeCloseTo(0.3);
```

#### 字符串比较，可以使用进行正则匹配

```js
expect("abcdefg").toMatch(/abc/);
expect("abcdefg").not.toMatch(/poiu/);
```

#### 查找数组或可迭代对象是否有指定项

```js
expect([1, 2, 3, 4]).toContain(1);
expect(new Set([1, 2, 3, 4])).toContain(1);
// 递归深度比较
expect([1, 2, { a: { b: 2 } }, 4]).toContainEqual({ a: { b: 1 } });
```

#### 检测是否是某个类的实例

```js
expect(new Person()).toBeInstanceOf(Person);
```

#### 是否报错

```js
expect(fn()).toThrow();
```

#### 快照和 mock 相关的会放在对应模块

#### 自定义

expect.extend 直接声明对应的方法，方法接受的参数为 expect 的参数，加上自身的参数
[不错的例子](https://github.com/testing-library/jest-dom/blob/main/src/matchers.js)
```js
expect(a).toFn(b, c, d) ===> expect.extend({ toFn(a,b,c,d) })
```

```js
// 小于10
expect(1 + 2).toLessTen();

expect.extend({
  toLessTen(recevied) {
    const pass = recevied < 10;
    return {
      pass,
      message: () => (pass ? "success" : "fail"),
    };
  },
});
```

## 异步处理

异步是 JS 常见的一个操作，但是 Jest 无法知道其什么时候结束才能跳转到下一个测试中去，因此需要告知 Jest，什么时候结束，它才能测到对应的内容

#### 调用 done 方法

在异步执行完成的时候使用 done 方法

```js
test("Test Async Function", (done) => {
  promise().then(() => {
    // do something
    done();
  });
});
```

#### 返回 promise

```js
test("Test Async Function", () => {
  return promise().then(() => {
    // do something
  });
});
```

#### 使用期望方法

.resolves / .rejects

```js
test("Test Async Function", () => {
  expect(promise())
    .resolves()
    .toBe();

  expect(promise())
    .rejects()
    .toBe();
});
```

#### async/await

```js
test("Test Async Function", async () => {
  await promise();
  // do something
});
```

#### 优先使用 async/await，其次是 done，因为这两者跟我们平时开发写 JS 的习惯更为接近，返回 promise 的写法容易忘记 return，使用期望则需要额外的成本，没有必要

## mock

很熟悉的名词吧，但是一般我们认为的 mock 就是模拟接口，是的，正如其含义“模拟的”，那么在 Jest 里，它也是模拟各种方法以供调用，包括模拟接口

先来补充几个 API，[具体看官方文档](https://www.jestjs.cn/docs/mock-function-api)

生成一个没有副作用的方法

```js
const mockFn = jest.fn();
```

:::tip
从源码中可以看到，它既可以直接被使用，也可以作为构造函数来 new 生成实例

```js
function fn(): Mock;

interface Mock<T = any, Y extends any[] = any> extends Function, MockInstance<T, Y> {
    new (...args: Y): T;
    (...args: Y): T;
}
```

:::

```js
const mockFn = jest.fn();
const instance1 = new mockFn();
const instance2 = new mockFn();
```

可以支持实现自定义方法

```js
const mockFn = jest.fn().mockImplementation((val) => val > 1);
expect(mockFn(3)).toBeTruthy();
```

可以设置返回值

```js
const mockFn = jest.fn().mockReturnValue({ code: 0 });
expect(mockFn()).toEqual({ code: 0 });
```

可以设置每一次的返回值，**所有API都是可以链式调用的**

```js
const mockFn = jest.fn().mockReturnValueOnce('first').mockReturnValueOnce('second');
expect(mockFn()).toBe('first');
expect(mockFn()).toBe('second');
```

也可以设置 Promise 返回结果

```js
test("Test Promise MockFn", async () => {
  let mockFn = jest.fn().mockResolvedValue("Promise resolve result");
  const result = await mockFn5();
  expect(result).toBe("Promise resolve result");
});
```

获取方法的参数和返回值

```js
let mockFn = jest.fn().mockImplementation((val) => val > 1);
expect(mockFn(3)).toBeTruthy();
expect(mockFn.mock.calls).toEqual([[3]]);
expect(mockFn.mock.results).toEqual([{ type: "return", value: true }]);
// 可以清空对应的calls，results和instance内容，一般会使用clearMock配置来自动每次清空
mockFn3.mockClear();
expect(mockFn3.mock.calls).toEqual([]);
expect(mockFn3.mock.results).toEqual([]);
```



接口请求处理，可以将写好的接口请求文件路径直接作为参数，传递给jest.mock
```js
// api.js
async function getList() {
  return fetch().then((data) => data)
}

export { getList }

// index.test.js
import { getList } from './getList'
jest.mock('./getList')

test('Test module mock', async () => {
  await getList();
  // 是否被调用以及调用次数
  expect(getList).toHaveBeenCalled();
  expect(getList).toHaveBeenCalledTimes(1);
});
```

### 待补充

## 快照

快照是通过将一次你认为正确的输出对象作为参照物存储起来，往后每一次都会和该参照物进行比较，如果不一样，就说明你的输出不正确，是一种很好的 UI 测试方式（不仅仅只是 UI 测试哦，也可以将配置快照下来）

```js
import React from "react";
import renderer from "react-test-renderer";
import Button from "./button";

it("renders correctly", () => {
  const tree = renderer.create(<Button>提交</Button>).toJSON();
  expect(tree).toMatchSnapshot();
});

// Snapshot file
exports[`renders correctly`] = `
<button>
  提交
</button>
`;
```

## 待续
