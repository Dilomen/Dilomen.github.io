(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{462:function(t,e,a){"use strict";a.r(e);var r=a(28),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[t._v("Fiber 是 React 为了解决组件更新时，阻塞当前更优先级的操作，比如输入内容变成卡顿。\n这个原因主要是因为原先的 React 渲染机制，就是同步的，"),a("em",[t._v("直到整个渲染完成")]),t._v("，才会去执行我们后续的操作。")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/JehTlyFIjmoA7pmqaj4Ncg",target:"_blank",rel:"noopener noreferrer"}},[t._v("有 react fiber，为什么不需要 vue fiber"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("React 原先是以栈的形式执行渲染整个 Render 树，执行完才能执行后面的操作")]),t._v(" "),a("div",{staticClass:"language-md line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[t._v("[parent, child1, child2]\n\nparent render\n  => child1 render => child1 mount\n  => child2 render => child2 mount\n  => parent mount\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[a("a",{attrs:{"data-fancybox":"",title:"react_fiber_1",href:"/框架/react_fiber_1.png"}},[a("img",{attrs:{src:"/%E6%A1%86%E6%9E%B6/react_fiber_1.png",alt:"react_fiber_1"}})])]),t._v(" "),a("p",[t._v("但是使用了 Fiber，每当时间片用完，都会停止当前的内容，来看是否有更高优先级的操作，如果有就执行，执行完，再"),a("em",[t._v("重新执行")]),t._v("刚才被打断的内容\n"),a("a",{attrs:{"data-fancybox":"",title:"react_fiber_2",href:"/框架/react_fiber_2.png"}},[a("img",{attrs:{src:"/%E6%A1%86%E6%9E%B6/react_fiber_2.png",alt:"react_fiber_2"}})])]),t._v(" "),a("p",[t._v("一个 Fiber 有两个更新阶段")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一阶段 Reconciliation Phase")]),t._v(" "),a("ul",[a("li",[t._v("componentWillMount")]),t._v(" "),a("li",[t._v("componentWillReceiveProps")]),t._v(" "),a("li",[t._v("shouldComponentUpdate")]),t._v(" "),a("li",[t._v("componentWillUpdate")])])]),t._v(" "),a("li",[a("p",[t._v("第二阶段 Commit Phase")]),t._v(" "),a("ul",[a("li",[t._v("componentDidMount")]),t._v(" "),a("li",[t._v("componentDidUpdate")]),t._v(" "),a("li",[t._v("componentWillUnmount")])])])]),t._v(" "),a("p",[t._v("第一阶段是会被中断的，第二阶段是一定不会被中断的")]),t._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"react_fiber_3",href:"/框架/react_fiber_3.png"}},[a("img",{attrs:{src:"/%E6%A1%86%E6%9E%B6/react_fiber_3.png",alt:'"react_fiber_3"'}})])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("为什么使用 Fiber 之后 componentWillMount 等生命周期会被执行多次？")]),t._v(" "),a("p",[t._v("因为这些生命周期是第一阶段的，如果被打断了，那么下次再重新执行的时候，该生命周期下的内容就会被再次执行，所以写代码的时候需要注意，这些生命周期中是否有一次执行更改的内容，以免出现问题")])]),t._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"react_fiber_4",href:"/框架/react_fiber_4.png"}},[a("img",{attrs:{src:"/%E6%A1%86%E6%9E%B6/react_fiber_4.png",alt:'"react_fiber_4"'}})])])])}),[],!1,null,null,null);e.default=n.exports}}]);