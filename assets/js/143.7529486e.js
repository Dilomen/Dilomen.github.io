(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{533:function(t,a,s){"use strict";s.r(a);var v=s(28),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v("浏览器的页面都是有 DOM 树和 CSS 树组合形成的 render 树渲染出来的，其也会形成一个文档流")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("文档流就是将所有在流中的元素从左到右，从上到下的排列规则")]),t._v(" "),s("p",[t._v("以下几种方式会脱离文档流")]),t._v(" "),s("ul",[s("li",[t._v("float")]),t._v(" "),s("li",[t._v("position: absolute")]),t._v(" "),s("li",[t._v("position: fixed")])])]),t._v(" "),s("h2",{attrs:{id:"重绘和回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘和回流"}},[t._v("#")]),t._v(" 重绘和回流")]),t._v(" "),s("h3",{attrs:{id:"重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),s("p",[t._v("当我们只改变元素的颜色等情况，不去改变元素的位置结构的话，那么就会引起重绘")]),t._v(" "),s("h3",{attrs:{id:"回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[t._v("#")]),t._v(" 回流")]),t._v(" "),s("p",[t._v("当我们改变了元素的大小等情况，那么浏览器就需要重新计算文档流中该元素后面的所有元素的排布，就会引起回流。所以"),s("em",[t._v("回流一定会引起重绘")])]),t._v(" "),s("h2",{attrs:{id:"优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[t._v("#")]),t._v(" 优化")]),t._v(" "),s("p",[t._v("那么减少重绘和回流，也是提升性能很重要的一个途径")]),t._v(" "),s("ul",[s("li",[t._v("避免使用 table 布局，因为单元格相互影响")]),t._v(" "),s("li",[t._v("使用添加 class 的方式，减少回流的次数")]),t._v(" "),s("li",[t._v("使用 transform 来改变元素")]),t._v(" "),s("li",[t._v("将改变应用到 absolute 等脱离文档流的元素上")]),t._v(" "),s("li",[t._v("将多次修改 DOM 的操作组合成一次，推荐 document.fragment")])])])}),[],!1,null,null,null);a.default=_.exports}}]);